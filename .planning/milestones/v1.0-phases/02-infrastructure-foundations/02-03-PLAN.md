---
phase: 02-infrastructure-foundations
plan: 03
type: execute
wave: 2
depends_on: ["02-02"]
files_modified:
  - next.config.ts
  - sentry.client.config.ts
  - sentry.server.config.ts
  - sentry.edge.config.ts
  - src/instrumentation.ts
  - src/app/global-error.tsx
autonomous: false
requirements: [DEV-03]
user_setup:
  - service: sentry
    why: "Error monitoring for client and server errors with source maps"
    env_vars:
      - name: SENTRY_DSN
        source: "Sentry Dashboard -> Settings -> Projects -> [project] -> Client Keys (DSN)"
      - name: NEXT_PUBLIC_SENTRY_DSN
        source: "Same DSN as SENTRY_DSN (public, used by browser SDK)"
      - name: SENTRY_AUTH_TOKEN
        source: "Sentry Dashboard -> Settings -> Auth Tokens -> Create New Token (org:read, project:releases, project:write)"
      - name: SENTRY_ORG
        source: "Sentry Dashboard -> Settings -> General -> Organization Slug"
      - name: SENTRY_PROJECT
        source: "Sentry Dashboard -> Settings -> Projects -> [project] -> Project Slug"
    dashboard_config:
      - task: "Create a Next.js project in Sentry"
        location: "Sentry Dashboard -> Projects -> Create Project -> Next.js"

must_haves:
  truths:
    - "Client-side JavaScript errors are captured and sent to Sentry"
    - "Server-side errors in API routes are captured and sent to Sentry"
    - "Source maps are uploaded to Sentry for readable stack traces"
    - "A global error boundary catches unhandled React errors"
  artifacts:
    - path: "sentry.client.config.ts"
      provides: "Sentry browser SDK initialization"
      contains: "Sentry.init"
    - path: "sentry.server.config.ts"
      provides: "Sentry Node.js SDK initialization"
      contains: "Sentry.init"
    - path: "sentry.edge.config.ts"
      provides: "Sentry Edge runtime initialization"
      contains: "Sentry.init"
    - path: "src/instrumentation.ts"
      provides: "Next.js instrumentation hook for Sentry"
      contains: "register"
    - path: "src/app/global-error.tsx"
      provides: "Global error boundary with Sentry reporting"
      contains: "captureException"
  key_links:
    - from: "next.config.ts"
      to: "@sentry/nextjs"
      via: "withSentryConfig wrapper"
      pattern: "withSentryConfig"
    - from: "src/instrumentation.ts"
      to: "sentry.server.config.ts"
      via: "dynamic import in register()"
      pattern: "import.*sentry"
    - from: "src/app/global-error.tsx"
      to: "@sentry/nextjs"
      via: "captureException call"
      pattern: "captureException"
---

<objective>
Install and configure Sentry error monitoring for client-side, server-side, and edge runtime errors with source map uploads.

Purpose: Production errors are currently invisible (console.error only). Sentry provides real-time error alerts, stack traces with source maps, and performance monitoring so the team can detect and fix issues before users report them.

Output: Sentry SDK configuration files, instrumentation hook, global error boundary, updated next.config.ts with Sentry wrapper
</objective>

<execution_context>
@/Users/szymonwilkosz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/szymonwilkosz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@next.config.ts
@src/app/layout.tsx
@.planning/phases/02-infrastructure-foundations/02-02-SUMMARY.md

<interfaces>
<!-- next.config.ts after Plan 02 applies security headers -->
<!-- Plan 02 adds: poweredByHeader: false, headers() with security headers -->
<!-- This plan wraps the entire config with withSentryConfig() -->

From next.config.ts (after Plan 02):
```typescript
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  poweredByHeader: false,
  images: { ... },
  headers: async () => [ ... ],
};

export default nextConfig;
```

From src/app/layout.tsx:
```typescript
export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="de" suppressHydrationWarning>
      <head>...</head>
      <body>...</body>
    </html>
  );
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Sentry SDK and create configuration files</name>
  <files>sentry.client.config.ts, sentry.server.config.ts, sentry.edge.config.ts, src/instrumentation.ts, src/app/global-error.tsx</files>
  <action>
**Step 1: Install Sentry SDK**

```bash
npm install @sentry/nextjs
```

**Step 2: Create `sentry.client.config.ts`** at project root:

```typescript
import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,

  // Performance monitoring: sample 10% of transactions in production
  tracesSampleRate: process.env.NODE_ENV === "production" ? 0.1 : 1.0,

  // Session replay: capture 1% of sessions, 100% of error sessions
  replaysSessionSampleRate: 0.01,
  replaysOnErrorSampleRate: 1.0,
  integrations: [
    Sentry.replayIntegration(),
  ],

  // Only enable in production (skip in dev to avoid noise)
  enabled: process.env.NODE_ENV === "production",

  // Environment tag
  environment: process.env.NODE_ENV,
});
```

**Step 3: Create `sentry.server.config.ts`** at project root:

```typescript
import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  tracesSampleRate: process.env.NODE_ENV === "production" ? 0.1 : 1.0,
  enabled: process.env.NODE_ENV === "production",
  environment: process.env.NODE_ENV,
});
```

**Step 4: Create `sentry.edge.config.ts`** at project root:

```typescript
import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  tracesSampleRate: process.env.NODE_ENV === "production" ? 0.1 : 1.0,
  enabled: process.env.NODE_ENV === "production",
  environment: process.env.NODE_ENV,
});
```

**Step 5: Create `src/instrumentation.ts`** (Next.js instrumentation hook):

```typescript
export async function register() {
  if (process.env.NEXT_RUNTIME === "nodejs") {
    await import("../sentry.server.config");
  }

  if (process.env.NEXT_RUNTIME === "edge") {
    await import("../sentry.edge.config");
  }
}

export const onRequestError = Sentry.captureRequestError;
```

For the `onRequestError` export, import Sentry at the top:
```typescript
import * as Sentry from "@sentry/nextjs";
```

**Step 6: Create `src/app/global-error.tsx`** (global error boundary):

```typescript
"use client";

import * as Sentry from "@sentry/nextjs";
import { useEffect } from "react";

export default function GlobalError({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    Sentry.captureException(error);
  }, [error]);

  return (
    <html lang="de">
      <body>
        <div style={{ padding: "2rem", textAlign: "center", fontFamily: "system-ui, sans-serif" }}>
          <h2 style={{ fontSize: "1.5rem", marginBottom: "1rem" }}>
            Ein Fehler ist aufgetreten
          </h2>
          <p style={{ color: "#666", marginBottom: "1.5rem" }}>
            Bitte versuchen Sie es erneut oder kontaktieren Sie uns.
          </p>
          <button
            onClick={() => reset()}
            style={{
              padding: "0.75rem 1.5rem",
              backgroundColor: "#000",
              color: "#fff",
              border: "none",
              borderRadius: "0.375rem",
              cursor: "pointer",
              fontSize: "1rem",
            }}
          >
            Erneut versuchen
          </button>
        </div>
      </body>
    </html>
  );
}
```

Note: This uses inline styles (not Tailwind) because global-error.tsx renders outside the normal layout tree and may not have access to the CSS bundle.
  </action>
  <verify>
    <automated>cd "/Users/szymonwilkosz/Library/Mobile Documents/com~apple~CloudDocs/claude-config/projects/next-office" && test -f sentry.client.config.ts && test -f sentry.server.config.ts && test -f sentry.edge.config.ts && test -f src/instrumentation.ts && test -f src/app/global-error.tsx && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>All Sentry config files created, instrumentation hook registers server and edge configs, global error boundary catches and reports errors to Sentry, TypeScript compiles</done>
</task>

<task type="auto">
  <name>Task 2: Wrap next.config.ts with withSentryConfig for source map uploads</name>
  <files>next.config.ts</files>
  <action>
Update `next.config.ts` to wrap the export with `withSentryConfig`:

1. Add import at top:
```typescript
import { withSentryConfig } from "@sentry/nextjs";
```

2. Keep the existing `nextConfig` object unchanged (with images, poweredByHeader, headers from Plan 02).

3. Change the export from:
```typescript
export default nextConfig;
```
to:
```typescript
export default withSentryConfig(nextConfig, {
  // Upload source maps to Sentry for readable stack traces
  org: process.env.SENTRY_ORG,
  project: process.env.SENTRY_PROJECT,

  // Only upload source maps during build (not dev)
  silent: !process.env.CI,

  // Wipe source maps after upload (don't expose to browser)
  wiping: {
    enabled: true,
  },

  // Tunnel Sentry events through the app to avoid ad blockers
  tunnelRoute: "/monitoring",

  // Disable Sentry telemetry
  disableLogger: true,

  // Automatically instrument API routes and server components
  autoInstrumentServerFunctions: true,
  autoInstrumentMiddleware: true,
});
```

**Important:** The `wiping` option ensures source maps are uploaded to Sentry but NOT served to browsers. The `tunnelRoute` creates a `/monitoring` endpoint that proxies Sentry events through the app's domain to avoid ad blockers. The `silent` flag suppresses build output unless in CI.

**CSP update:** The Content-Security-Policy in the headers() function needs an additional `connect-src` entry for the Sentry ingest domain. However, since we're using `tunnelRoute: "/monitoring"`, Sentry events go through `'self'` which is already allowed. No CSP change needed.
  </action>
  <verify>
    <automated>cd "/Users/szymonwilkosz/Library/Mobile Documents/com~apple~CloudDocs/claude-config/projects/next-office" && grep -c "withSentryConfig" next.config.ts && grep -c "@sentry/nextjs" next.config.ts && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>next.config.ts wrapped with withSentryConfig, source maps uploaded during build, tunnel route configured, TypeScript compiles</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify Sentry integration</name>
  <files>sentry.client.config.ts, sentry.server.config.ts, src/app/global-error.tsx</files>
  <action>
Human verification checkpoint. Sentry SDK installed and configured for client, server, and edge. Global error boundary added. Source map upload configured in next.config.ts.

Steps to verify:
1. Ensure you have created a Sentry project and set env vars (SENTRY_DSN, NEXT_PUBLIC_SENTRY_DSN, SENTRY_AUTH_TOKEN, SENTRY_ORG, SENTRY_PROJECT) in .env.local
2. Run `npm run dev` and navigate to any page
3. Open browser console and run: `throw new Error("Sentry test from client")`
4. Check Sentry Dashboard -> Issues — the error should appear within 60 seconds
5. If DSN env vars are not set yet, verify the build completes: `npm run build` (Sentry is disabled when DSN is empty)
6. Confirm `/monitoring` tunnel route is accessible (should return 200 or proxy to Sentry)

Resume signal: Type "approved" or describe issues found.
  </action>
  <verify>
    <automated>cd "/Users/szymonwilkosz/Library/Mobile Documents/com~apple~CloudDocs/claude-config/projects/next-office" && npm ls @sentry/nextjs && test -f sentry.client.config.ts && test -f sentry.server.config.ts && test -f src/app/global-error.tsx && echo "All Sentry files present"</automated>
  </verify>
  <done>User confirms Sentry errors appear in dashboard within 60 seconds, or confirms build succeeds without DSN configured</done>
</task>

</tasks>

<verification>
1. `npm ls @sentry/nextjs` — package installed
2. `cat sentry.client.config.ts` — Sentry.init with DSN and replay
3. `cat sentry.server.config.ts` — Sentry.init with DSN
4. `cat src/instrumentation.ts` — register() imports configs, exports onRequestError
5. `cat src/app/global-error.tsx` — captureException on error
6. `grep "withSentryConfig" next.config.ts` — config wrapped
7. `npx tsc --noEmit` — zero errors
</verification>

<success_criteria>
- @sentry/nextjs installed in package.json
- Client, server, and edge Sentry configs initialized with DSN
- Instrumentation hook loads correct config per runtime
- Global error boundary catches and reports unhandled React errors
- next.config.ts wrapped with withSentryConfig for source map uploads
- Tunnel route configured at /monitoring for ad-blocker bypass
- Sentry disabled in development (enabled only in production)
- TypeScript compiles with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-infrastructure-foundations/02-03-SUMMARY.md`
</output>
