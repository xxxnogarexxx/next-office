---
phase: 04-performance-architecture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/cities.ts
  - src/lib/listings.ts
  - src/data/listings-card.json
  - src/lib/types.ts
  - src/components/lead-form.tsx
  - src/components/search-bar.tsx
  - src/app/(main)/page.tsx
  - src/app/(main)/api/transit/route.ts
  - src/components/listing-card.tsx
autonomous: true
requirements: [PERF-01, PERF-06, PERF-07, PERF-08]

must_haves:
  truths:
    - "LeadForm and SearchBar import cities from src/lib/cities.ts, NOT from src/lib/listings.ts"
    - "src/lib/cities.ts exports cities array without importing listings.json"
    - "A listings-card.json file exists with only the fields needed for ListingCard rendering (no description, publicTransport, etc.)"
    - "src/lib/listings.ts exports card listings from listings-card.json for list views and full listings from listings.json for detail views"
    - "Transit API responds with Cache-Control: public, max-age=3600 on success"
    - "Transit API uses 30s timeout and retries once with 2s backoff on failure"
  artifacts:
    - path: "src/lib/cities.ts"
      provides: "Standalone cities module without listings.json dependency"
      exports: ["cities", "getCityBySlug", "City"]
    - path: "src/data/listings-card.json"
      provides: "Lightweight listings payload for card rendering (~100KB vs 630KB)"
      contains: "ListingCard-relevant fields only"
    - path: "src/lib/listings.ts"
      provides: "Split data access — card listings for list views, full listings for detail"
      exports: ["cardListings", "listings", "getListingsByCity", "getListingBySlug", "getCityBySlug", "displayPrice", "displayCapacity"]
  key_links:
    - from: "src/components/lead-form.tsx"
      to: "src/lib/cities.ts"
      via: "import { cities } from '@/lib/cities'"
      pattern: "from.*@/lib/cities"
    - from: "src/lib/listings.ts"
      to: "src/data/listings-card.json"
      via: "import cardListingsData"
      pattern: "listings-card\\.json"
---

<objective>
Split the listings data layer so client components only receive lightweight card data, extract cities into a standalone module to break the LeadForm dependency on listings.json, and harden the transit API with proper timeout/retry/caching.

Purpose: The 630KB listings.json is currently bundled into every page that imports from `@/lib/listings`. By splitting the data and extracting cities, we eliminate the largest client payload. The transit API hardening fixes timeout and caching gaps.

Output: New `src/lib/cities.ts` module, new `src/data/listings-card.json` lightweight payload, refactored `src/lib/listings.ts` with split exports, updated consumer imports, hardened transit API route.
</objective>

<execution_context>
@/Users/szymonwilkosz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/szymonwilkosz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/lib/types.ts:
```typescript
export interface Listing {
  contentfulId: string;
  id: string;
  name: string;
  slug: string;
  description: string;
  city: string;
  citySlug: string;
  country: string;
  address: string;
  postalCode: string;
  latitude: number | null;
  longitude: number | null;
  capacityMin: number | null;
  capacityMax: number | null;
  priceFrom: number | null;
  priceTo: number | null;
  areaSqm: number | null;
  noticePeriod: string | null;
  amenities: string[];
  photos: string[];
  coverPhoto: string | null;
  providerName: string | null;
  providerWebsite: string | null;
  publicTransport: string | null;
  flexDeskPrice: number | null;
  fixedDeskPrice: number | null;
  privateOfficePrice: number | null;
  featured: boolean;
}

export interface City {
  name: string;
  slug: string;
  country: string;
  listingCount: number;
  image: string;
  latitude: number;
  longitude: number;
}
```

From src/lib/listings.ts (current):
```typescript
import listingsData from "@/data/listings.json";
import citiesData from "@/data/cities.json";

export const listings: Listing[] = listingsData as Listing[];
export const cities: City[] = citiesData as City[];

export function getListingsByCity(citySlug: string): Listing[]
export function getListingBySlug(slug: string): Listing | undefined
export function getCityBySlug(slug: string): City | undefined
export function displayPrice(price: number | null): string
export function displayCapacity(min: number | null, max: number | null): string
```

Consumers of `cities` from `@/lib/listings`:
- src/components/lead-form.tsx — uses `cities` for city dropdown (name, slug)
- src/components/search-bar.tsx — uses `cities` for search dropdown (name, slug, listingCount)
- src/app/(main)/page.tsx — uses `cities` for city cards (name, slug, image, listingCount)
- src/app/sitemap.ts — uses `cities` for sitemap generation

Consumers of `listings` from `@/lib/listings`:
- src/app/(main)/search/page.tsx — uses `listings` for search grid
- src/app/(main)/[city]/page.tsx — uses `getCityBySlug`, `getListingsByCity`, `listings as allListings`
- src/app/(main)/[city]/layout.tsx — uses `getCityBySlug`
- src/app/(main)/[city]/[listing]/page.tsx — uses `getListingBySlug`, `getListingsByCity`
- src/app/sitemap.ts — uses `listings` for URL generation

Fields used by ListingCard (the only card-level consumer):
- id, name, slug, citySlug, city, address, photos, coverPhoto, providerName, capacityMin, capacityMax, priceFrom, latitude, longitude
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract cities module and create lightweight listings-card.json</name>
  <files>
    src/lib/cities.ts
    src/lib/types.ts
    src/data/listings-card.json
    src/lib/listings.ts
    src/components/lead-form.tsx
    src/components/search-bar.tsx
    src/components/listing-card.tsx
    src/app/(main)/page.tsx
  </files>
  <action>
    **Step 1: Create `src/lib/cities.ts`** — standalone cities module.
    ```typescript
    import type { City } from "./types";
    import citiesData from "@/data/cities.json";

    export type { City };
    export const cities: City[] = citiesData as City[];

    export function getCityBySlug(slug: string): City | undefined {
      return cities.find((c) => c.slug === slug);
    }
    ```

    **Step 2: Add `ListingCard` type to `src/lib/types.ts`** — add a new interface representing the lightweight listing payload for card views:
    ```typescript
    export interface ListingCard {
      id: string;
      name: string;
      slug: string;
      city: string;
      citySlug: string;
      address: string;
      latitude: number | null;
      longitude: number | null;
      capacityMin: number | null;
      capacityMax: number | null;
      priceFrom: number | null;
      photos: string[];
      coverPhoto: string | null;
      providerName: string | null;
    }
    ```

    **Step 3: Generate `src/data/listings-card.json`** — write a script inline (or use a Node one-liner via bash) to read `src/data/listings.json` and output a new JSON file containing only the ListingCard fields for each listing. This reduces the ~630KB payload to ~100-120KB. The script should:
    - Read listings.json
    - For each listing, extract ONLY: id, name, slug, city, citySlug, address, latitude, longitude, capacityMin, capacityMax, priceFrom, photos, coverPhoto, providerName
    - Write to listings-card.json
    - Run `node -e "..."` to generate the file

    **Step 4: Refactor `src/lib/listings.ts`** — split into card and full data access:
    ```typescript
    import type { Listing, ListingCard as ListingCardType, City } from "./types";
    import listingsData from "@/data/listings.json";
    import cardListingsData from "@/data/listings-card.json";
    import { cities, getCityBySlug } from "./cities";

    export type { Listing, ListingCardType as ListingCard, City };
    export { cities, getCityBySlug };

    // Full listings — only used by detail page and sitemap (server-side only)
    export const listings: Listing[] = listingsData as Listing[];

    // Card listings — lightweight, used by search/city pages
    export const cardListings: ListingCardType[] = cardListingsData as ListingCardType[];

    export function getListingsByCity(citySlug: string): Listing[] {
      return listings.filter((l) => l.citySlug === citySlug);
    }

    export function getCardListingsByCity(citySlug: string): ListingCardType[] {
      return cardListings.filter((l) => l.citySlug === citySlug);
    }

    export function getListingBySlug(slug: string): Listing | undefined {
      return listings.find((l) => l.slug === slug);
    }

    export function displayPrice(price: number | null): string {
      if (price === null) return "Auf Anfrage";
      return `ab ${price} €/Monat`;
    }

    export function displayCapacity(min: number | null, max: number | null): string {
      if (min !== null && max !== null) return `${min}–${max} Personen`;
      if (max !== null) return `bis ${max} Personen`;
      if (min !== null) return `ab ${min} Personen`;
      return "Auf Anfrage";
    }
    ```

    **Step 5: Update consumer imports** — change files that only need `cities` to import from `@/lib/cities` instead of `@/lib/listings`:
    - `src/components/lead-form.tsx`: Change `import { cities } from "@/lib/listings"` to `import { cities } from "@/lib/cities"`
    - `src/components/search-bar.tsx`: Same change
    - `src/app/(main)/page.tsx`: Same change

    **IMPORTANT**: Do NOT change `src/app/sitemap.ts` — it needs both cities and listings for URL generation and runs server-side only, so the full import is acceptable.

    **IMPORTANT**: Do NOT yet change the city page or search page imports — Plan 02 handles their full server component refactor. The split data (`cardListings`, `getCardListingsByCity`) will be consumed in Plan 02.

    **Step 6: Update ListingCard component to accept the lighter type.**
    In `src/components/listing-card.tsx`, change the import and props to use `ListingCard` type:
    - Change `import type { Listing } from "@/lib/types"` to `import type { ListingCard as ListingCardData } from "@/lib/types"`
    - Change the `ListingCardProps` interface to use `listing: ListingCardData` instead of `listing: Listing`
    The component only uses fields present in `ListingCard` (id, name, slug, citySlug, city, address, photos, coverPhoto, providerName, capacityMin, capacityMax, priceFrom) so this is a safe narrowing. Keep the `"use client"` directive.
  </action>
  <verify>
    <automated>
      cd /Users/szymonwilkosz/Library/Mobile\ Documents/com~apple~CloudDocs/claude-config/projects/next-office && node -e "
        const cities = require('./src/data/cities.json');
        const card = require('./src/data/listings-card.json');
        const full = require('./src/data/listings.json');
        const cardSize = JSON.stringify(card).length;
        const fullSize = JSON.stringify(full).length;
        const cardFields = Object.keys(card[0]).sort().join(',');
        const expectedFields = 'address,capacityMax,capacityMin,city,citySlug,coverPhoto,id,latitude,longitude,name,photos,priceFrom,providerName,slug';
        console.log('cities count:', cities.length);
        console.log('card listings count:', card.length, '(should match full:', full.length, ')');
        console.log('card size:', cardSize, 'vs full size:', fullSize, '- reduction:', Math.round((1 - cardSize/fullSize) * 100) + '%');
        console.log('card fields match:', cardFields === expectedFields ? 'PASS' : 'FAIL — got: ' + cardFields);
        if (card.length !== full.length) process.exit(1);
        if (cardFields !== expectedFields) process.exit(1);
        console.log('ALL CHECKS PASSED');
      "
    </automated>
  </verify>
  <done>
    - src/lib/cities.ts exists and exports cities + getCityBySlug without importing listings.json
    - src/data/listings-card.json exists with only card-relevant fields, ~80% smaller than listings.json
    - src/lib/listings.ts exports both cardListings and listings, re-exports cities from cities.ts
    - lead-form.tsx, search-bar.tsx, and page.tsx (homepage) import cities from @/lib/cities
    - ListingCard type added to types.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Harden transit API with 30s timeout, retry with backoff, and Cache-Control headers</name>
  <files>
    src/app/(main)/api/transit/route.ts
  </files>
  <action>
    Refactor `src/app/(main)/api/transit/route.ts` to address PERF-06 and PERF-07:

    **Timeout**: Change the AbortController timeout from 12000ms to 30000ms (30s). The Overpass API can be slow and 12s is too aggressive.

    **Retry with backoff**: Add a retry wrapper around the Overpass fetch. On first failure (network error or non-2xx response), wait 2 seconds, then retry once. Only retry on 5xx or network errors — do NOT retry on 4xx (client errors from Overpass). Implementation:
    ```typescript
    async function fetchWithRetry(url: string, init: RequestInit, retries = 1, backoffMs = 2000): Promise<Response> {
      for (let attempt = 0; attempt <= retries; attempt++) {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 30000);
        try {
          const res = await fetch(url, { ...init, signal: controller.signal });
          clearTimeout(timeout);
          if (res.ok || res.status < 500) return res; // Don't retry client errors
          if (attempt < retries) {
            await new Promise(r => setTimeout(r, backoffMs));
            continue;
          }
          return res; // Return last failed response
        } catch (err) {
          clearTimeout(timeout);
          if (attempt < retries) {
            await new Promise(r => setTimeout(r, backoffMs));
            continue;
          }
          throw err;
        }
      }
      throw new Error("Unreachable");
    }
    ```

    **Cache-Control headers**: On successful responses (200), add `Cache-Control: public, max-age=3600` (1 hour). Transit data for a given lat/lng does not change frequently. On error responses (502), add `Cache-Control: no-store` to prevent caching errors.

    Update the GET handler to use `fetchWithRetry` and add the appropriate headers:
    ```typescript
    // Success path
    return NextResponse.json(data, {
      headers: { "Cache-Control": "public, max-age=3600" },
    });

    // Error paths
    return NextResponse.json(
      { elements: [], error: `Overpass returned ${res.status}` },
      { status: 502, headers: { "Cache-Control": "no-store" } }
    );
    ```

    Keep the existing `parseCoord` and `ALLOWED_QUERY_TYPES` unchanged — they were hardened in Phase 1.
  </action>
  <verify>
    <automated>
      cd /Users/szymonwilkosz/Library/Mobile\ Documents/com~apple~CloudDocs/claude-config/projects/next-office && grep -c "max-age=3600" src/app/\(main\)/api/transit/route.ts && grep -c "30000" src/app/\(main\)/api/transit/route.ts && grep -c "fetchWithRetry" src/app/\(main\)/api/transit/route.ts && echo "ALL TRANSIT CHECKS PASSED"
    </automated>
  </verify>
  <done>
    - Transit API uses 30s timeout (was 12s)
    - Transit API retries once with 2s backoff on 5xx/network errors
    - Successful responses include Cache-Control: public, max-age=3600
    - Error responses include Cache-Control: no-store
  </done>
</task>

</tasks>

<verification>
1. `grep -r "from.*@/lib/listings" src/components/lead-form.tsx src/components/search-bar.tsx src/app/\(main\)/page.tsx` returns NO matches (they now import from @/lib/cities)
2. `ls src/data/listings-card.json` confirms file exists
3. `ls src/lib/cities.ts` confirms file exists
4. `node -e "console.log(JSON.stringify(require('./src/data/listings-card.json')).length)"` shows payload significantly smaller than listings.json
5. Transit route.ts contains `max-age=3600`, `30000` timeout, and `fetchWithRetry`
6. Build passes: `npx next build` completes without errors (if dev environment supports it)
</verification>

<success_criteria>
- LeadForm, SearchBar, and homepage import cities from @/lib/cities — no listings.json in their bundle
- listings-card.json exists with ~14 fields per listing (vs ~30 in full) and is >60% smaller
- Transit API has 30s timeout, retry with backoff, and Cache-Control headers
- All existing functionality is preserved — no regressions in city/search/listing pages
</success_criteria>

<output>
After completion, create `.planning/phases/04-performance-architecture/04-01-SUMMARY.md`
</output>
