---
phase: 12-monitoring-observability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/(main)/api/health/tracking/route.ts
autonomous: true
requirements:
  - MON-01

must_haves:
  truths:
    - "GET /api/health/tracking returns HTTP 200 with a JSON body containing counts for pending, uploaded, failed, and dead_letter queue items"
    - "The response includes a timestamp and overall pipeline status ('healthy' if no failed/dead_letter, 'degraded' if any failed items, 'critical' if any dead_letter items)"
    - "The endpoint uses service role client (not anon) since conversion_queue has no anon SELECT RLS policy"
    - "The endpoint uses force-dynamic to prevent Next.js caching stale counts"
  artifacts:
    - path: "src/app/(main)/api/health/tracking/route.ts"
      provides: "GET handler returning conversion pipeline health metrics"
      contains: "export async function GET"
  key_links:
    - from: "src/app/(main)/api/health/tracking/route.ts"
      to: "supabase/migrations/003_conversion_queue.sql"
      via: "queries conversion_queue table grouped by status"
      pattern: "conversion_queue"
---

<objective>
Create the `/api/health/tracking` endpoint that reports conversion pipeline health by querying the conversion_queue table for status distribution counts.

Purpose: Operations visibility -- a single GET request shows whether the offline conversion pipeline is healthy (items flowing through) or degraded (items stuck in failed/dead_letter state). This is the first endpoint to check when investigating conversion upload issues.
Output: 1 file -- API route handler for tracking health.
</objective>

<execution_context>
@/Users/szymonwilkosz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/szymonwilkosz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@supabase/migrations/003_conversion_queue.sql

Key facts from prior phases and STATE.md decisions:
- conversion_queue table: status CHECK ('pending', 'uploaded', 'failed', 'dead_letter')
- Service role client used for server-side reads on tables with no anon RLS (pattern from Phase 8: resolveVisitorUuid in src/lib/leads/supabase.ts)
- API routes live under (main)/api/ route group (not bare src/app/api/)
- Existing health endpoint at /api/health checks env var presence (Phase 2) -- this is a SEPARATE endpoint at /api/health/tracking
- Tracking failures return HTTP 200 with { success: false } -- tracking errors must not degrade user experience (established pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create /api/health/tracking endpoint with queue status counts</name>
  <files>src/app/(main)/api/health/tracking/route.ts</files>
  <action>
Create `src/app/(main)/api/health/tracking/route.ts` with the following implementation:

```typescript
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

export const dynamic = "force-dynamic";

/**
 * GET /api/health/tracking
 *
 * Reports conversion pipeline health by querying conversion_queue status distribution.
 *
 * Returns:
 * - status: "healthy" (no failed/dead_letter), "degraded" (failed > 0), "critical" (dead_letter > 0)
 * - counts: { pending, uploaded, failed, dead_letter }
 * - timestamp: ISO 8601
 *
 * Always returns HTTP 200 — the JSON status field indicates pipeline health.
 * Uses service role client — conversion_queue has no anon SELECT RLS policy.
 */
export async function GET() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

  if (!url || !serviceRoleKey) {
    return NextResponse.json(
      {
        status: "error",
        message: "Supabase credentials not configured",
        timestamp: new Date().toISOString(),
      },
      { status: 200 }
    );
  }

  const supabase = createClient(url, serviceRoleKey, {
    auth: { persistSession: false },
  });

  // Query all queue items and count by status.
  // The conversion_queue table is small (B2B volume) so a full scan is fine.
  // Four separate count queries are cleaner than a GROUP BY that requires
  // post-processing to fill in missing statuses.
  const [pending, uploaded, failed, deadLetter] = await Promise.all([
    supabase
      .from("conversion_queue")
      .select("id", { count: "exact", head: true })
      .eq("status", "pending"),
    supabase
      .from("conversion_queue")
      .select("id", { count: "exact", head: true })
      .eq("status", "uploaded"),
    supabase
      .from("conversion_queue")
      .select("id", { count: "exact", head: true })
      .eq("status", "failed"),
    supabase
      .from("conversion_queue")
      .select("id", { count: "exact", head: true })
      .eq("status", "dead_letter"),
  ]);

  // Check for query errors -- if any count query fails, report degraded
  const queryError =
    pending.error || uploaded.error || failed.error || deadLetter.error;

  if (queryError) {
    return NextResponse.json(
      {
        status: "error",
        message: "Failed to query conversion queue",
        error: queryError.message,
        timestamp: new Date().toISOString(),
      },
      { status: 200 }
    );
  }

  const counts = {
    pending: pending.count ?? 0,
    uploaded: uploaded.count ?? 0,
    failed: failed.count ?? 0,
    dead_letter: deadLetter.count ?? 0,
  };

  // Derive pipeline health status:
  // - critical: any dead_letter items (unrecoverable failures)
  // - degraded: any failed items (retrying, may recover)
  // - healthy: only pending and uploaded (normal operation)
  let pipelineStatus: "healthy" | "degraded" | "critical" = "healthy";
  if (counts.dead_letter > 0) {
    pipelineStatus = "critical";
  } else if (counts.failed > 0) {
    pipelineStatus = "degraded";
  }

  return NextResponse.json(
    {
      status: pipelineStatus,
      counts,
      timestamp: new Date().toISOString(),
    },
    { status: 200 }
  );
}
```

Key implementation notes:
- Service role client created inline (same pattern as `resolveVisitorUuid` in `src/lib/leads/supabase.ts`) -- no shared factory needed for a single endpoint
- Uses `{ count: "exact", head: true }` for efficient counting without fetching row data
- Four parallel count queries (not GROUP BY) -- ensures all four status keys are always present in the response even when count is 0
- `force-dynamic` prevents Next.js from caching stale health data
- Pipeline status derived from counts: healthy > degraded (failed) > critical (dead_letter)
- Always returns HTTP 200 -- the `status` field in the JSON body carries the health signal (consistent with the existing `/api/health` pattern)
  </action>
  <verify>
    <automated>grep -c "export async function GET" src/app/\(main\)/api/health/tracking/route.ts && grep -c "conversion_queue" src/app/\(main\)/api/health/tracking/route.ts && grep -c "dead_letter" src/app/\(main\)/api/health/tracking/route.ts</automated>
  </verify>
  <done>GET /api/health/tracking returns JSON with { status, counts: { pending, uploaded, failed, dead_letter }, timestamp } using service role client</done>
</task>

</tasks>

<verification>
1. File exists: `src/app/(main)/api/health/tracking/route.ts`
2. Exports a GET handler
3. Uses service role client (not anon) for conversion_queue access
4. Returns all four status counts: pending, uploaded, failed, dead_letter
5. Returns pipeline health status derived from counts
6. Uses `force-dynamic` to prevent caching
</verification>

<success_criteria>
GET /api/health/tracking returns a JSON response containing:
- `status`: one of "healthy", "degraded", "critical"
- `counts.pending`: number
- `counts.uploaded`: number
- `counts.failed`: number
- `counts.dead_letter`: number
- `timestamp`: ISO 8601 string
</success_criteria>

<output>
After completion, create `.planning/phases/12-monitoring-observability/12-01-SUMMARY.md`
</output>
