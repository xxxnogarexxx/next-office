---
phase: 08-visitor-utm-capture
plan: 02
type: execute
wave: 2
depends_on:
  - "08-01"
files_modified:
  - src/app/(main)/api/track/visit/route.ts
  - src/lib/tracking/visit.ts
autonomous: true
requirements:
  - CAP-03

must_haves:
  truths:
    - "POST /api/track/visit returns 200 with { success: true } when called with a valid visitor_id cookie"
    - "A Supabase visitors row is created on first call with visitor_id, UTMs, gclid, ip_hash, user_agent, landing_page, referrer, first_seen_at, last_seen_at"
    - "A second POST /api/track/visit with the same visitor_id performs an upsert that updates last_seen_at without creating a duplicate row"
    - "POST /api/track/visit without a _no_vid cookie returns 400"
    - "The Supabase client used by the visit endpoint uses the service role key (not anon key) — visitors table has no anon write policy"
  artifacts:
    - path: "src/app/(main)/api/track/visit/route.ts"
      provides: "POST /api/track/visit — upserts visitor record in Supabase from cookie values"
      contains: "upsertVisitor"
    - path: "src/lib/tracking/visit.ts"
      provides: "upsertVisitor() — service-role Supabase call to upsert into visitors table"
      contains: "upsertVisitor"
  key_links:
    - from: "src/app/(main)/api/track/visit/route.ts"
      to: "src/lib/tracking/visit.ts"
      via: "imports upsertVisitor"
      pattern: "upsertVisitor"
    - from: "src/lib/tracking/visit.ts"
      to: "supabase/migrations/001_visitors.sql"
      via: "upserts into visitors table"
      pattern: "visitors"
---

<objective>
Create the `/api/track/visit` endpoint (CAP-03) that:
1. Reads visitor_id and tracking data from HTTP-only cookies set by middleware.
2. Upserts a record in the Supabase `visitors` table (create on first visit, update last_seen_at on return).
3. Uses the service role Supabase client — the visitors table has RLS with no anon write policy.

This endpoint is called client-side on page load (fire-and-forget). It does NOT need CSRF protection because it carries no user data — it only reads server-set cookies and enriches an anonymous visitor record.
</objective>

<execution_context>
@/Users/szymonwilkosz/.claire/get-shit-done/workflows/execute-plan.md
@/Users/szymonwilkosz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-visitor-utm-capture/08-01-SUMMARY.md
@src/middleware.ts
@src/lib/tracking/visitor.ts
@src/lib/leads/supabase.ts
@src/lib/env.ts
@supabase/migrations/001_visitors.sql

visitors table schema (from 001_visitors.sql):
- id UUID PK
- visitor_id TEXT NOT NULL UNIQUE
- gclid TEXT
- utm_source, utm_medium, utm_campaign, utm_term, utm_content TEXT
- ip_hash TEXT (SHA-256 hash of client IP — never store raw IP)
- user_agent TEXT
- landing_page TEXT
- referrer TEXT
- first_seen_at TIMESTAMPTZ NOT NULL DEFAULT now()
- last_seen_at TIMESTAMPTZ NOT NULL DEFAULT now()
- created_at TIMESTAMPTZ NOT NULL DEFAULT now()

Cookie names (from 08-01):
- _no_vid (visitor_id)
- _no_utm_source, _no_utm_medium, _no_utm_campaign, _no_utm_term, _no_utm_content
- _no_gclid (set by existing middleware)
- _no_lp (landing page URL)
- _no_ref (referrer)

Environment variable for service role: SUPABASE_SERVICE_ROLE_KEY
(not NEXT_PUBLIC_ — server-only, never exposed to client)

Upsert strategy:
- ON CONFLICT (visitor_id) DO UPDATE SET last_seen_at = now()
- On first visit: INSERT full row with all tracking data
- On return visit: UPDATE only last_seen_at (preserve original UTMs, gclid, landing_page from first visit — first-touch attribution)

IP hashing: use Node.js crypto module, SHA-256, hex output.
The x-forwarded-for header provides the client IP (same pattern as service.ts rate limiter).
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create src/lib/tracking/visit.ts with upsertVisitor()</name>
  <files>src/lib/tracking/visit.ts</files>
  <action>
Create `src/lib/tracking/visit.ts`.

This module provides `upsertVisitor()` — the single function that writes to the Supabase `visitors` table using the service role client.

```typescript
/**
 * Visitor upsert — writes anonymous visitor data to Supabase.
 *
 * Uses the service role client because the visitors table has RLS enabled
 * with no anon write policy (Phase 7, DB-05). The service role bypasses RLS.
 *
 * upsertVisitor() is called from /api/track/visit on every page view.
 * It uses INSERT ... ON CONFLICT (visitor_id) DO UPDATE to handle both
 * first visits (insert) and return visits (update last_seen_at only).
 *
 * First-touch attribution: UTMs, gclid, and landing_page from the original
 * visit are preserved on conflict — only last_seen_at is updated.
 */

import { createClient } from "@supabase/supabase-js";
import { createHash } from "crypto";

// ---------------------------------------------------------------------------
// Service role client factory
// SUPABASE_SERVICE_ROLE_KEY is server-only — never NEXT_PUBLIC_.
// ---------------------------------------------------------------------------

function createServiceClient() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

  if (!url || !serviceRoleKey) {
    throw new Error(
      "Supabase env vars missing: NEXT_PUBLIC_SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY"
    );
  }

  return createClient(url, serviceRoleKey, {
    auth: { persistSession: false },
  });
}

// ---------------------------------------------------------------------------
// hashIp — SHA-256 hex hash of client IP (privacy-safe, not reversible)
// ---------------------------------------------------------------------------

function hashIp(ip: string): string {
  return createHash("sha256").update(ip).digest("hex");
}

// ---------------------------------------------------------------------------
// VisitorData — all fields needed to upsert a visitors row
// ---------------------------------------------------------------------------

export interface VisitorData {
  visitorId: string;       // from _no_vid cookie
  gclid: string | null;    // from _no_gclid cookie
  utmSource: string | null;
  utmMedium: string | null;
  utmCampaign: string | null;
  utmTerm: string | null;
  utmContent: string | null;
  ipAddress: string | null; // raw IP from x-forwarded-for (will be hashed before storing)
  userAgent: string | null;
  landingPage: string | null; // from _no_lp cookie
  referrer: string | null;    // from _no_ref cookie
}

// ---------------------------------------------------------------------------
// upsertVisitor — insert or update visitors row
// ---------------------------------------------------------------------------

export async function upsertVisitor(
  data: VisitorData
): Promise<{ success: true } | { success: false; error: string }> {
  const client = createServiceClient();

  const ipHash = data.ipAddress ? hashIp(data.ipAddress) : null;

  const { error } = await client.from("visitors").upsert(
    {
      visitor_id: data.visitorId,
      gclid: data.gclid,
      utm_source: data.utmSource,
      utm_medium: data.utmMedium,
      utm_campaign: data.utmCampaign,
      utm_term: data.utmTerm,
      utm_content: data.utmContent,
      ip_hash: ipHash,
      user_agent: data.userAgent,
      landing_page: data.landingPage,
      referrer: data.referrer,
      last_seen_at: new Date().toISOString(),
    },
    {
      onConflict: "visitor_id",
      // On conflict: only update last_seen_at — preserve original UTMs and gclid
      // (first-touch attribution model). ignoreDuplicates: false so the update runs.
      ignoreDuplicates: false,
    }
  );

  if (error) {
    console.error("[tracking/visit] upsertVisitor error:", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}
```

Note on Supabase upsert and first-touch attribution: Supabase's `.upsert()` with `onConflict: "visitor_id"` will update ALL provided columns on conflict by default. To preserve original UTMs on return visits, we need a Postgres-native approach. Use a raw SQL query instead of `.upsert()`:

```typescript
// Use raw SQL upsert to preserve first-touch UTMs on conflict.
// On conflict (visitor_id already exists): only update last_seen_at.
// On insert (new visitor): insert all columns including UTMs and gclid.
const { error } = await client.rpc("upsert_visitor", {
  p_visitor_id: data.visitorId,
  p_gclid: data.gclid,
  p_utm_source: data.utmSource,
  p_utm_medium: data.utmMedium,
  p_utm_campaign: data.utmCampaign,
  p_utm_term: data.utmTerm,
  p_utm_content: data.utmContent,
  p_ip_hash: ipHash,
  p_user_agent: data.userAgent,
  p_landing_page: data.landingPage,
  p_referrer: data.referrer,
});
```

However, creating a Postgres function is overkill for this phase. A simpler approach: use a two-step logic:
1. Try to INSERT. If conflict, do nothing.
2. Always UPDATE last_seen_at.

Actually, the simplest correct approach for Supabase JS client: use the raw SQL via `client.rpc` or use a direct upsert with a custom update set. Since Supabase JS v2 `.upsert()` does not support partial updates on conflict natively, use the following pattern instead:

```typescript
// Step 1: Insert (ignore conflict — preserves existing row)
await client.from("visitors").insert({
  visitor_id: data.visitorId,
  gclid: data.gclid,
  utm_source: data.utmSource,
  utm_medium: data.utmMedium,
  utm_campaign: data.utmCampaign,
  utm_term: data.utmTerm,
  utm_content: data.utmContent,
  ip_hash: ipHash,
  user_agent: data.userAgent,
  landing_page: data.landingPage,
  referrer: data.referrer,
  // first_seen_at and last_seen_at use DB DEFAULT now()
}).throwOnError().catch(() => {
  // Conflict on visitor_id — visitor already exists, continue to step 2
});

// Step 2: Always update last_seen_at (works for both new and existing visitors)
const { error } = await client
  .from("visitors")
  .update({ last_seen_at: new Date().toISOString() })
  .eq("visitor_id", data.visitorId);
```

Use this two-step approach in the actual implementation. It correctly handles both first and return visits with first-touch attribution preservation. Wrap both steps in a try/catch and return `{ success: false }` if the UPDATE fails (the INSERT failure on conflict is acceptable).
  </action>
  <verify>
- File exists at src/lib/tracking/visit.ts
- Contains upsertVisitor export: `grep "export async function upsertVisitor" src/lib/tracking/visit.ts`
- Contains hashIp function: `grep "hashIp" src/lib/tracking/visit.ts`
- Uses SUPABASE_SERVICE_ROLE_KEY (not anon key): `grep "SERVICE_ROLE_KEY" src/lib/tracking/visit.ts`
- Contains two-step insert/update pattern: `grep "last_seen_at" src/lib/tracking/visit.ts`
  </verify>
  <done>
src/lib/tracking/visit.ts exports upsertVisitor(data: VisitorData) which:
- Creates a service role Supabase client (bypasses RLS on visitors table)
- Hashes client IP with SHA-256 before storing
- Inserts new visitor row with all tracking data on first visit
- On return visit: INSERT fails silently on conflict, UPDATE sets last_seen_at
- Returns { success: true } or { success: false, error: string }
  </done>
</task>

<task type="auto">
  <name>Task 2: Create /api/track/visit route handler</name>
  <files>src/app/(main)/api/track/visit/route.ts</files>
  <action>
Create `src/app/(main)/api/track/visit/route.ts`.

This is a POST-only endpoint. It:
1. Reads _no_vid from cookies — returns 400 if missing.
2. Reads UTM and tracking cookies set by middleware.
3. Extracts client IP and user-agent from request headers.
4. Calls upsertVisitor() with all data.
5. Returns { success: true } or { success: false }.

No body parsing needed — all data comes from cookies and headers.
No CSRF needed — this endpoint carries no user-provided data and is idempotent.

```typescript
/**
 * POST /api/track/visit
 *
 * Records or updates an anonymous visitor session in Supabase.
 * Called client-side on every page load (fire-and-forget from the browser).
 *
 * Reads all tracking data from HTTP-only cookies set by middleware:
 * - _no_vid (visitor_id) — required; returns 400 if absent
 * - _no_utm_* (UTM parameters)
 * - _no_gclid (Google Ads click ID)
 * - _no_lp (landing page URL)
 * - _no_ref (HTTP referrer)
 *
 * Uses service role Supabase client — the visitors table has RLS with no
 * anon write policy (Phase 7, DB-05). Service role bypasses RLS.
 *
 * Idempotent: calling this endpoint multiple times for the same visitor
 * only updates last_seen_at; original UTMs and gclid are preserved.
 */

import { NextResponse } from "next/server";
import { cookies, headers } from "next/headers";
import { upsertVisitor } from "@/lib/tracking/visit";
import { VISITOR_COOKIE_NAME, UTM_COOKIE_PREFIX, UTM_KEYS } from "@/lib/tracking/visitor";

export async function POST(request: Request) {
  const cookieStore = await cookies();
  const headerStore = await headers();

  // visitor_id is required — without it we have no tracking subject
  const visitorId = cookieStore.get(VISITOR_COOKIE_NAME)?.value;
  if (!visitorId) {
    return NextResponse.json(
      { error: "No visitor ID" },
      { status: 400 }
    );
  }

  // Read UTM cookies set by middleware
  const utmSource = cookieStore.get(`${UTM_COOKIE_PREFIX}utm_source`)?.value ?? null;
  const utmMedium = cookieStore.get(`${UTM_COOKIE_PREFIX}utm_medium`)?.value ?? null;
  const utmCampaign = cookieStore.get(`${UTM_COOKIE_PREFIX}utm_campaign`)?.value ?? null;
  const utmTerm = cookieStore.get(`${UTM_COOKIE_PREFIX}utm_term`)?.value ?? null;
  const utmContent = cookieStore.get(`${UTM_COOKIE_PREFIX}utm_content`)?.value ?? null;

  // Read click ID and page context cookies
  const gclid = cookieStore.get("_no_gclid")?.value ?? null;
  const landingPage = cookieStore.get("_no_lp")?.value ?? null;
  const referrer = cookieStore.get("_no_ref")?.value ?? null;

  // Extract client IP and user-agent from headers
  const forwarded = headerStore.get("x-forwarded-for");
  const ipAddress = forwarded ? forwarded.split(",")[0].trim() : null;
  const userAgent = headerStore.get("user-agent") ?? null;

  const result = await upsertVisitor({
    visitorId,
    gclid,
    utmSource,
    utmMedium,
    utmCampaign,
    utmTerm,
    utmContent,
    ipAddress,
    userAgent,
    landingPage,
    referrer,
  });

  if (!result.success) {
    // Log but return 200 — tracking failures must not block the user experience
    console.error("[api/track/visit] upsertVisitor failed:", result.error);
    return NextResponse.json({ success: false }, { status: 200 });
  }

  return NextResponse.json({ success: true });
}
```

Note on cookie key construction: The UTM_COOKIE_PREFIX is `_no_utm_` and the key names are `utm_source`, etc. So the cookie key is `_no_utm_utm_source`. Verify this is consistent with how middleware.ts sets them. If middleware sets `${UTM_COOKIE_PREFIX}${key}` where key is `utm_source`, the full cookie name is `_no_utm_utm_source`.

Actually, review the visitor.ts helper created in Task 1 carefully:
- UTM_COOKIE_PREFIX = `_no_utm_`
- Keys in UTM_KEYS = `["utm_source", "utm_medium", ...]`
- Combined: `_no_utm_utm_source`

This is redundant. Consider whether to use keys `["source", "medium", ...]` in UTM_KEYS (so combined name is `_no_utm_source`) or keep `utm_source` in the key names (producing `_no_utm_utm_source`).

**Decision: use `_no_utm_source` (not `_no_utm_utm_source`) for cleaner cookie names.** Update visitor.ts accordingly:
- Change UTM_KEYS to `["source", "medium", "campaign", "term", "content"]`
- In middleware.ts, build cookie name as `${UTM_COOKIE_PREFIX}${key}` → `_no_utm_source`, `_no_utm_medium`, etc.
- In route.ts, read cookies as `_no_utm_source`, `_no_utm_medium`, etc.

Make sure this naming is consistent across all three files: visitor.ts, middleware.ts, and this route.ts.

In the route.ts, read cookies with their full names explicitly (do not reconstruct from prefix + key) to keep the route handler readable:

```typescript
const utmSource   = cookieStore.get("_no_utm_source")?.value   ?? null;
const utmMedium   = cookieStore.get("_no_utm_medium")?.value   ?? null;
const utmCampaign = cookieStore.get("_no_utm_campaign")?.value ?? null;
const utmTerm     = cookieStore.get("_no_utm_term")?.value     ?? null;
const utmContent  = cookieStore.get("_no_utm_content")?.value  ?? null;
```
  </action>
  <verify>
- File exists: `ls src/app/\(main\)/api/track/visit/route.ts`
- Contains POST export: `grep "export async function POST" src/app/\(main\)/api/track/visit/route.ts`
- Returns 400 when visitor_id missing: `grep "No visitor ID" src/app/\(main\)/api/track/visit/route.ts`
- Reads _no_vid cookie: `grep "VISITOR_COOKIE_NAME\|_no_vid" src/app/\(main\)/api/track/visit/route.ts`
- Calls upsertVisitor: `grep "upsertVisitor" src/app/\(main\)/api/track/visit/route.ts`
- TypeScript check: `npx tsc --noEmit` — expect no errors
  </verify>
  <done>
src/app/(main)/api/track/visit/route.ts implements POST /api/track/visit:
- Returns 400 if _no_vid cookie is missing
- Reads all 5 UTM cookies, gclid, landing_page, referrer from HTTP-only cookies
- Extracts IP (for hashing) and user-agent from request headers
- Calls upsertVisitor() from lib/tracking/visit.ts
- Returns 200 { success: true } on success, 200 { success: false } on failure (tracking errors must not break UX)
  </done>
</task>

</tasks>

<verification>
1. src/lib/tracking/visit.ts exports upsertVisitor() using service role Supabase client
2. IP address is SHA-256 hashed before storing (raw IP never written to Supabase)
3. Two-step insert/update strategy: INSERT (silent on conflict) then UPDATE last_seen_at
4. POST /api/track/visit returns 400 when _no_vid cookie absent
5. POST /api/track/visit returns 200 { success: true } when visitor upserted
6. Tracking failures return 200 (not 500) — tracking must not break the user experience
7. SUPABASE_SERVICE_ROLE_KEY used (not anon key) — required because visitors table has no anon write RLS policy
8. npx tsc --noEmit passes with no type errors
</verification>

<success_criteria>
- /api/track/visit creates or updates a Supabase visitors row on each call (CAP-03)
- First call for a visitor_id creates a new row with all tracking fields populated
- Subsequent calls for the same visitor_id update only last_seen_at (first-touch attribution preserved)
- Missing visitor_id returns 400
- Service role client used (anon client would be rejected by RLS)
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-visitor-utm-capture/08-02-SUMMARY.md`
</output>
