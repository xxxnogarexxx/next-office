---
phase: 13-main-site-visitor-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/tracking-provider.tsx
autonomous: true
requirements:
  - CAP-03 (extended)
  - CAP-04 (extended)

must_haves:
  truths:
    - "A main-site page load fires POST /api/track/visit and creates a visitors row in Supabase"
    - "A lead submitted via the main-site form has a non-null visitor_id FK pointing to the visitors row"
    - "The CRM webhook matchLeadByEmail() JOIN retrieves gclid for main-site leads when visitor had gclid"
  artifacts:
    - path: "src/components/tracking-provider.tsx"
      provides: "Visit tracking fire-and-forget call on mount"
      contains: "fetch.*api/track/visit"
  key_links:
    - from: "src/components/tracking-provider.tsx"
      to: "/api/track/visit"
      via: "fetch POST on useEffect mount"
      pattern: "fetch.*api/track/visit"
    - from: "/api/track/visit"
      to: "Supabase visitors table"
      via: "upsertVisitor() in src/lib/tracking/visit.ts"
      pattern: "upsertVisitor"
    - from: "src/lib/leads/service.ts"
      to: "Supabase visitors table"
      via: "resolveVisitorUuid() — already wired, but needs visitor row to exist"
      pattern: "resolveVisitorUuid"
---

<objective>
Add visit tracking to the main-site TrackingProvider so that main-site visitors create a Supabase visitors row, enabling visitor_id FK on leads and gclid attribution via the CRM webhook.

Purpose: Currently only LP pages fire `/api/track/visit` (via LPTrackingProvider). Main-site visitors never get a Supabase visitors row, so `resolveVisitorUuid()` returns null and leads submitted via `/api/leads` have no visitor_id FK — breaking gclid attribution for main-site leads.

Output: Updated `src/components/tracking-provider.tsx` with fire-and-forget visit tracking call.
</objective>

<execution_context>
@/Users/szymonwilkosz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/szymonwilkosz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->
<!-- Executor should use these directly — no codebase exploration needed. -->

From src/components/tracking-provider.tsx (CURRENT — to be modified):
```typescript
"use client";
import { createContext, useContext, useEffect, useState, type ReactNode } from "react";

interface TrackingData {
  gclid: string | null;
  gbraid: string | null;
  wbraid: string | null;
  landing_page: string | null;
  referrer: string | null;
}

export function useTracking(): TrackingData;
export function TrackingProvider({ children }: { children: ReactNode }): JSX.Element;
```

From src/components/lp/tracking/lp-tracking-provider.tsx (REFERENCE — shows the pattern):
```typescript
// Fire visit tracking on page load — records visitor session in Supabase.
// Runs once per page load. Errors are non-fatal (tracking must not break UX).
useEffect(() => {
  fetch("/api/track/visit", {
    method: "POST",
    credentials: "same-origin",
  }).catch((err) => {
    console.error("[lp-tracking] visit tracking failed:", err);
  });
}, []);
```

From src/app/(main)/layout.tsx (CONSUMER — wraps all main-site pages):
```typescript
import { TrackingProvider } from "@/components/tracking-provider";
// TrackingProvider wraps Header + main + Footer
```

From src/app/(main)/api/track/visit/route.ts:
```typescript
// POST handler reads all tracking data from HTTP-only cookies set by middleware.
// Calls upsertVisitor() which uses service role Supabase client.
// Returns 200 always (tracking errors are non-fatal).
export async function POST(): Promise<NextResponse>;
```

From src/lib/leads/service.ts (step 5b — already wired):
```typescript
// Step 5b: Resolve visitor_id cookie to UUID primary key in visitors table.
const visitorIdText = cookieStore.get("_no_vid")?.value ?? null;
const visitorUuid = await resolveVisitorUuid(visitorIdText);
// ... later:
const insertResult = await insertLead(resolvedData, visitorUuid, emailHash);
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add fire-and-forget visit tracking to main-site TrackingProvider</name>
  <files>src/components/tracking-provider.tsx</files>
  <action>
Add a useEffect to TrackingProvider that fires `POST /api/track/visit` on mount, identical to the pattern used in LPTrackingProvider.

Specifically, add a new useEffect BEFORE the existing URL-param-reading useEffect:

```typescript
// Fire visit tracking on page load — records visitor session in Supabase.
// Runs once per page load. Errors are non-fatal (tracking must not break UX).
// Mirrors LPTrackingProvider behavior so main-site visitors also get a
// visitors row, enabling visitor_id FK on leads and gclid attribution.
useEffect(() => {
  fetch("/api/track/visit", {
    method: "POST",
    credentials: "same-origin",
  }).catch((err) => {
    console.error("[tracking] visit tracking failed:", err);
  });
}, []);
```

Key details:
- `credentials: "same-origin"` is required — the endpoint reads HTTP-only cookies set by middleware (_no_vid, _no_gclid, UTMs)
- Empty dependency array `[]` — fire once on mount only
- `.catch()` to prevent unhandled promise rejection — tracking must never break UX
- Console prefix is `[tracking]` (not `[lp-tracking]`) to distinguish from LP provider logs
- No other changes to TrackingProvider — the existing click ID reading logic stays as-is
- No new imports needed — `fetch` is a global

Do NOT:
- Remove or modify the existing useEffect that reads gclid/gbraid/wbraid from URL params
- Change the TrackingData interface
- Add any sessionStorage usage (main-site doesn't need it — cookies handle persistence)
  </action>
  <verify>
    <automated>grep -c "api/track/visit" src/components/tracking-provider.tsx</automated>
  </verify>
  <done>
- TrackingProvider fires POST /api/track/visit on mount with credentials: "same-origin"
- Error is caught and logged (non-fatal)
- Existing click ID URL param reading is unchanged
- Main-site page loads will now create/update visitors rows in Supabase via the existing endpoint
  </done>
</task>

</tasks>

<verification>
1. `grep "api/track/visit" src/components/tracking-provider.tsx` — confirms the visit tracking call is present
2. `grep "credentials.*same-origin" src/components/tracking-provider.tsx` — confirms cookies are sent
3. `npx tsc --noEmit` — no type errors introduced
4. Manual flow verification (for later):
   - Load a main-site page → check Network tab for POST /api/track/visit → verify 200 response
   - Submit main-site lead form → check Supabase leads table → verify visitor_id FK is non-null
   - Verify CRM webhook matchLeadByEmail for a main-site lead retrieves gclid from joined visitor
</verification>

<success_criteria>
- src/components/tracking-provider.tsx contains a useEffect that fires POST /api/track/visit on mount
- The fetch call uses credentials: "same-origin" so HTTP-only cookies are sent
- Errors are caught (non-fatal) — tracking never breaks the main site UX
- No existing TrackingProvider functionality is altered
</success_criteria>

<output>
After completion, create `.planning/phases/13-main-site-visitor-tracking/13-01-SUMMARY.md`
</output>
