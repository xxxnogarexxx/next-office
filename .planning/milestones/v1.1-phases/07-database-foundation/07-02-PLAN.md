---
phase: 07-database-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - "07-01"
files_modified:
  - supabase/migrations/005_leads_extension.sql
autonomous: true
requirements:
  - DB-02
  - DB-05

must_haves:
  truths:
    - "A leads row can be linked to a visitor via FK (visitor_id column references visitors table)"
    - "A leads row contains UTM columns (utm_source, utm_medium, utm_campaign, utm_term, utm_content)"
    - "A leads row contains email_hash (SHA-256 hex string)"
    - "A leads row contains conversion_status tracking the lead's lifecycle"
    - "A leads row contains consent fields for GDPR tracking"
  artifacts:
    - path: "supabase/migrations/005_leads_extension.sql"
      provides: "ALTER TABLE leads adding visitor_id FK, UTM columns, email_hash, consent fields, conversion_status"
      contains: "ALTER TABLE leads"
  key_links:
    - from: "supabase/migrations/005_leads_extension.sql"
      to: "supabase/migrations/001_visitors.sql"
      via: "FK reference from leads.visitor_id to visitors(id)"
      pattern: "REFERENCES.*visitors"
---

<objective>
Extend the existing leads table with new columns for visitor attribution, UTM tracking, email hashing, consent, and conversion lifecycle. This bridges the existing lead capture system with the new tracking infrastructure.

Purpose: Existing leads table only stores gclid/gbraid/wbraid and basic form data. v1.1 requires visitor_id FK (to link leads to anonymous visitor sessions), UTM columns (for campaign attribution), email_hash (for Enhanced Conversions), consent fields (for GDPR), and conversion_status (for pipeline state).
Output: 1 SQL migration file that ALTERs the existing leads table.
</objective>

<execution_context>
@/Users/szymonwilkosz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/szymonwilkosz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-database-foundation/07-CONTEXT.md
@.planning/phases/07-database-foundation/07-01-SUMMARY.md
@src/lib/leads/supabase.ts
@src/lib/leads/validation.ts

Existing leads table columns (from insertLead in supabase.ts):
- name, email, phone, team_size, start_date, city, message
- listing_id, listing_name
- gclid, gbraid, wbraid
- landing_page, referrer
- created_at (implicit, Supabase default)
- id (implicit, Supabase default UUID PK)

Key context from CONTEXT.md decisions:
- Standard ALTER TABLE migration — site just launched, minimal existing data
- Existing leads table gets: visitor_id FK, UTM columns, email_hash, consent fields, conversion_status
- RLS already configured on leads table (anon insert allowed per v1.0 decision)
- New columns on leads do NOT need separate RLS changes — leads table RLS is already set up

Note: The leads table already has gclid/gbraid/wbraid columns. UTM columns may or may not exist — the validation.ts shows utm_source etc. in ValidatedLeadData but insertLead does NOT write them. Check existing schema carefully. The ALTER should use IF NOT EXISTS pattern or be idempotent.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend leads table with visitor, attribution, and conversion columns</name>
  <files>supabase/migrations/005_leads_extension.sql</files>
  <action>
Create `supabase/migrations/005_leads_extension.sql`.

This migration ALTERs the existing `leads` table. Since the site just launched with minimal data, a standard ALTER TABLE is safe. Use ADD COLUMN IF NOT EXISTS for idempotency (allows re-running without error).

**New columns to add:**

Visitor linkage:
- `visitor_id` UUID REFERENCES visitors(id) ON DELETE SET NULL — nullable FK, lead may exist without visitor tracking (e.g., leads created before v1.1)

UTM columns (leads currently do NOT store UTMs in the database even though ValidatedLeadData has them — insertLead in supabase.ts does not write utm_* fields):
- `utm_source` TEXT
- `utm_medium` TEXT
- `utm_campaign` TEXT
- `utm_term` TEXT
- `utm_content` TEXT

Enhanced Conversions:
- `email_hash` TEXT — SHA-256 hex string of normalized lowercase email, computed at form submission time (Phase 9)

Consent tracking:
- `consent_marketing` BOOLEAN DEFAULT false — user consented to marketing communications
- `consent_data_processing` BOOLEAN DEFAULT false — user consented to data processing
- `consent_recorded_at` TIMESTAMPTZ — when consent was captured

Conversion lifecycle:
- `conversion_status` TEXT DEFAULT 'new' CHECK (conversion_status IN ('new', 'qualified', 'closed', 'lost')) — tracks where the lead is in the sales pipeline. Updated by CRM webhook (Phase 10).

Timestamps:
- `updated_at` TIMESTAMPTZ DEFAULT now() — leads table likely has created_at but may not have updated_at. Add it if missing.

**Indexes:**
- `idx_leads_visitor_id` ON leads(visitor_id) WHERE visitor_id IS NOT NULL — partial index for visitor-to-lead lookups
- `idx_leads_email_hash` ON leads(email_hash) WHERE email_hash IS NOT NULL — for CRM webhook matching (Phase 10 OFL-02)
- `idx_leads_conversion_status` ON leads(conversion_status) — for pipeline status queries

**Updated_at trigger (optional but recommended):**
Create a function + trigger that auto-updates `updated_at` on row modification:

```sql
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER leads_updated_at
  BEFORE UPDATE ON leads
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

Also apply this trigger to visitors, conversions, and conversion_queue tables (they also have updated_at columns — add triggers for all in this migration file since it runs after the others).

**RLS note:** The leads table already has RLS configured for anon insert access (v1.0). No RLS changes needed here. The new columns are automatically covered by existing policies. DB-05 requires RLS on visitors, conversions, conversion_queue, and tracking_events — NOT on leads (leads already has it). However, confirm leads RLS is enabled with a comment.
  </action>
  <verify>
Validate SQL:
- Confirm ALTER TABLE leads ADD COLUMN statements for all required columns
- Confirm visitor_id REFERENCES visitors(id) FK constraint
- Confirm conversion_status CHECK constraint with 4 values
- Confirm indexes on visitor_id, email_hash, conversion_status
- Run: `grep -c "ADD COLUMN" supabase/migrations/005_leads_extension.sql` — expect at least 10 columns
- Run: `grep "REFERENCES visitors" supabase/migrations/005_leads_extension.sql` — expect match
- Run: `grep "CHECK" supabase/migrations/005_leads_extension.sql` — expect conversion_status constraint
  </verify>
  <done>
leads table extended with:
- visitor_id UUID FK to visitors(id) — links leads to visitor sessions
- 5 UTM columns (source, medium, campaign, term, content) — Phase 8 will write these
- email_hash TEXT — Phase 9 will compute SHA-256 at form submission
- consent_marketing, consent_data_processing BOOLEAN + consent_recorded_at TIMESTAMPTZ
- conversion_status TEXT with CHECK ('new','qualified','closed','lost')
- updated_at TIMESTAMPTZ with auto-update trigger
- Partial indexes on visitor_id, email_hash, and conversion_status
- updated_at trigger applied to leads, visitors, conversions, and conversion_queue tables
  </done>
</task>

</tasks>

<verification>
1. leads table has visitor_id column with FK to visitors(id)
2. leads table has all 5 UTM columns
3. leads table has email_hash TEXT column
4. leads table has consent_marketing, consent_data_processing, consent_recorded_at columns
5. leads table has conversion_status with CHECK constraint
6. Indexes exist for visitor_id (partial), email_hash (partial), conversion_status
7. updated_at auto-update trigger works on leads, visitors, conversions, conversion_queue
</verification>

<success_criteria>
- 005_leads_extension.sql creates all required columns without error
- visitor_id FK correctly references visitors(id) created in Plan 01
- conversion_status CHECK matches pipeline stages (new, qualified, closed, lost)
- email_hash column ready for SHA-256 hex strings (Phase 9)
- Consent fields present for future GDPR compliance
- Auto-update trigger on updated_at for all tables with that column
</success_criteria>

<output>
After completion, create `.planning/phases/07-database-foundation/07-02-SUMMARY.md`
</output>
