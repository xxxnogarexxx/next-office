---
phase: 10-offline-conversion-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/conversions/webhook.ts
  - src/lib/conversions/queue.ts
  - src/app/api/webhooks/crm-conversion/route.ts
autonomous: true
requirements:
  - OFL-01
  - OFL-02
  - OFL-03
  - OFL-04

must_haves:
  truths:
    - "A POST to /api/webhooks/crm-conversion with a valid HMAC signature returns 200; an invalid or missing signature returns 401"
    - "A webhook payload with a known email matches to the Supabase lead row and retrieves the lead's stored gclid and email_hash"
    - "A conversion record is created with idempotency_key = {crm_deal_id}:{conversion_type} — a second call with the same key does not create a duplicate"
    - "A queue entry is created for google_ads platform when the matched lead has gclid or email_hash attribution data"
    - "A webhook payload with an unknown email returns 200 with { success: false, reason: 'lead_not_found' } — does not error"
    - "The conversion row contains denormalized gclid, email_hash, and UTM columns copied from the matched lead"
  artifacts:
    - path: "src/lib/conversions/webhook.ts"
      provides: "Webhook signature validation, payload parsing, lead matching, conversion+queue creation"
      contains: "verifyWebhookSignature"
    - path: "src/lib/conversions/queue.ts"
      provides: "createQueueEntry() helper that inserts into conversion_queue for google_ads platform"
      contains: "createQueueEntry"
    - path: "src/app/api/webhooks/crm-conversion/route.ts"
      provides: "POST handler delegating to webhook.ts business logic"
      contains: "export async function POST"
  key_links:
    - from: "src/app/api/webhooks/crm-conversion/route.ts"
      to: "src/lib/conversions/webhook.ts"
      via: "imports handleCrmWebhook"
      pattern: "handleCrmWebhook"
    - from: "src/lib/conversions/webhook.ts"
      to: "supabase/migrations/002_conversions.sql"
      via: "inserts into conversions table with idempotency_key"
      pattern: "idempotency_key"
    - from: "src/lib/conversions/webhook.ts"
      to: "src/lib/conversions/queue.ts"
      via: "calls createQueueEntry after conversion insert"
      pattern: "createQueueEntry"
---

<objective>
Build the CRM webhook endpoint that receives conversion notifications from NetHunt CRM, validates authenticity, matches to Supabase leads, creates idempotent conversion records, and queues them for Google Ads upload.

Purpose: This is the entry point of the offline conversion pipeline. When a CRM deal reaches "qualified" or "closed" status, NetHunt fires a webhook. This plan handles everything from receiving that webhook to having a queue entry ready for upload.
Output: 3 files — route handler, webhook business logic module, queue helper module.
</objective>

<execution_context>
@/Users/szymonwilkosz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/szymonwilkosz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/leads/supabase.ts
@src/lib/leads/service.ts
@supabase/migrations/002_conversions.sql
@supabase/migrations/003_conversion_queue.sql
@supabase/migrations/005_leads_extension.sql

Key facts from prior phases and STATE.md decisions:
- Supabase service role client is used for server-side DB access (pattern from Phase 8: resolveVisitorUuid)
- conversions table: id, lead_id FK, conversion_type CHECK ('qualified','closed'), conversion_value, conversion_currency DEFAULT 'EUR', idempotency_key UNIQUE, crm_deal_id, gclid, email_hash, utm_source, utm_medium, utm_campaign, created_at, updated_at
- conversion_queue table: id, conversion_id FK, platform DEFAULT 'google_ads', status CHECK ('pending','uploaded','failed','dead_letter'), retry_count DEFAULT 0, max_retries DEFAULT 5, next_retry_at, last_error, uploaded_at, created_at, updated_at
- leads table has: email_hash (SHA-256 hex), visitor_id FK, utm_source/medium/campaign/term/content, conversion_status CHECK ('new','qualified','closed','lost'), gclid (via visitor join)
- Idempotency key format: {crm_deal_id}:{conversion_type}
- Direct CRM webhook from NetHunt — no n8n in the loop
- Tracking failures return 200 with { success: false } — errors must not cause webhook retries
- HMAC-SHA256 pattern already established in CSRF module (src/lib/leads/csrf.ts)
- Google Ads customer ID: 215-246-8876, Manager: 670-646-4060
- Env var for webhook secret: CRM_WEBHOOK_SECRET (new, must be configured in NetHunt + Vercel)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create webhook business logic module and queue helper</name>
  <files>src/lib/conversions/webhook.ts, src/lib/conversions/queue.ts</files>
  <action>
Create `src/lib/conversions/` directory.

**src/lib/conversions/queue.ts:**

Create a helper module for queue operations:

```typescript
/**
 * Conversion queue operations for offline conversion pipeline.
 *
 * Creates queue entries that the Supabase Edge Function processor (Phase 10 Plan 03)
 * picks up every 15 minutes and uploads to Google Ads API.
 */

import { createClient } from "@supabase/supabase-js";

function createServiceClient() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

/**
 * Create a queue entry for a conversion to be uploaded to a given platform.
 *
 * Only creates an entry if the conversion has attribution data (gclid or email_hash).
 * Returns { created: true } if queued, { created: false, reason } if skipped.
 */
export async function createQueueEntry(
  conversionId: string,
  gclid: string | null,
  emailHash: string | null,
  platform: string = "google_ads"
): Promise<{ created: true } | { created: false; reason: string }> {
  // OFL-04: Only queue if we have attribution data
  if (!gclid && !emailHash) {
    return { created: false, reason: "no_attribution_data" };
  }

  const supabase = createServiceClient();

  const { error } = await supabase.from("conversion_queue").insert({
    conversion_id: conversionId,
    platform,
    status: "pending",
    retry_count: 0,
    max_retries: 5,
    next_retry_at: null, // null = immediate pickup on next cron run
  });

  if (error) {
    console.error("[queue] Failed to create queue entry:", error.message);
    return { created: false, reason: error.message };
  }

  return { created: true };
}
```

**src/lib/conversions/webhook.ts:**

Create the main webhook handling module:

```typescript
/**
 * CRM webhook handler for offline conversion pipeline.
 *
 * Receives webhook from NetHunt CRM when a deal status changes to
 * qualified or closed. Validates signature, matches lead by email,
 * creates idempotent conversion record, and queues for Google Ads upload.
 *
 * Flow: NetHunt webhook → validate HMAC → match lead by email → insert conversion
 *       → queue for upload → return result
 */

import { createHash, createHmac, timingSafeEqual } from "crypto";
import { createClient } from "@supabase/supabase-js";
import { createQueueEntry } from "./queue";

// --- Types ---

interface WebhookPayload {
  crm_deal_id: string;
  email: string;
  conversion_type: "qualified" | "closed";
  conversion_value?: number;
  conversion_currency?: string;
}

interface WebhookResult {
  success: boolean;
  reason?: string;
  conversion_id?: string;
  queued?: boolean;
}

// --- Helpers ---

function createServiceClient() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

/**
 * Verify HMAC-SHA256 webhook signature (OFL-01).
 *
 * NetHunt sends the raw body signed with the shared secret.
 * The signature is expected in the X-Webhook-Signature header.
 *
 * Uses timing-safe comparison to prevent timing attacks.
 */
export function verifyWebhookSignature(
  rawBody: string,
  signature: string | null,
  secret: string
): boolean {
  if (!signature) return false;

  const expected = createHmac("sha256", secret)
    .update(rawBody)
    .digest("hex");

  // Ensure constant-time comparison
  try {
    const sigBuffer = Buffer.from(signature, "hex");
    const expectedBuffer = Buffer.from(expected, "hex");
    if (sigBuffer.length !== expectedBuffer.length) return false;
    return timingSafeEqual(sigBuffer, expectedBuffer);
  } catch {
    return false;
  }
}

/**
 * Parse and validate webhook payload.
 *
 * Validates required fields and conversion_type enum.
 * Returns parsed payload or null if invalid.
 */
function parsePayload(body: unknown): WebhookPayload | null {
  if (!body || typeof body !== "object") return null;

  const b = body as Record<string, unknown>;

  if (typeof b.crm_deal_id !== "string" || !b.crm_deal_id) return null;
  if (typeof b.email !== "string" || !b.email) return null;
  if (b.conversion_type !== "qualified" && b.conversion_type !== "closed") return null;

  return {
    crm_deal_id: b.crm_deal_id,
    email: b.email.trim().toLowerCase(),
    conversion_type: b.conversion_type,
    conversion_value: typeof b.conversion_value === "number" ? b.conversion_value : undefined,
    conversion_currency: typeof b.conversion_currency === "string" ? b.conversion_currency : undefined,
  };
}

/**
 * Match incoming deal email to a Supabase lead (OFL-02).
 *
 * Looks up the lead by email_hash (SHA-256 of normalized email).
 * If found, retrieves the lead's gclid via the visitor FK join,
 * plus email_hash and UTM columns directly from the lead row.
 *
 * Returns the most recent lead matching the email hash (ORDER BY created_at DESC).
 */
async function matchLeadByEmail(email: string) {
  const supabase = createServiceClient();

  // Hash the email to match against leads.email_hash (set by Phase 9 EC-03)
  const emailHash = createHash("sha256")
    .update(email.trim().toLowerCase())
    .digest("hex");

  // Query lead with visitor join to get gclid
  const { data, error } = await supabase
    .from("leads")
    .select(`
      id,
      email_hash,
      utm_source,
      utm_medium,
      utm_campaign,
      visitor_id,
      visitors!leads_visitor_id_fkey (
        gclid
      )
    `)
    .eq("email_hash", emailHash)
    .order("created_at", { ascending: false })
    .limit(1)
    .single();

  if (error || !data) {
    return null;
  }

  // Extract gclid from joined visitor row
  const visitor = data.visitors as { gclid: string | null } | null;
  const gclid = visitor?.gclid ?? null;

  return {
    lead_id: data.id as string,
    gclid,
    email_hash: data.email_hash as string | null,
    utm_source: data.utm_source as string | null,
    utm_medium: data.utm_medium as string | null,
    utm_campaign: data.utm_campaign as string | null,
  };
}

/**
 * Create conversion record with idempotency key (OFL-03).
 *
 * Uses INSERT ... ON CONFLICT (idempotency_key) DO NOTHING to prevent duplicates.
 * Returns the conversion id (existing or new).
 */
async function createConversion(
  payload: WebhookPayload,
  lead: NonNullable<Awaited<ReturnType<typeof matchLeadByEmail>>>
): Promise<{ id: string; is_duplicate: boolean } | null> {
  const supabase = createServiceClient();
  const idempotencyKey = `${payload.crm_deal_id}:${payload.conversion_type}`;

  // Try to insert — ON CONFLICT does nothing if key exists
  const { data: inserted, error: insertError } = await supabase
    .from("conversions")
    .insert({
      lead_id: lead.lead_id,
      conversion_type: payload.conversion_type,
      conversion_value: payload.conversion_value ?? null,
      conversion_currency: payload.conversion_currency ?? "EUR",
      idempotency_key: idempotencyKey,
      crm_deal_id: payload.crm_deal_id,
      // Denormalized attribution (avoids JOINs in queue processor)
      gclid: lead.gclid,
      email_hash: lead.email_hash,
      utm_source: lead.utm_source,
      utm_medium: lead.utm_medium,
      utm_campaign: lead.utm_campaign,
    })
    .select("id")
    .single();

  // If insert succeeded, return new conversion
  if (!insertError && inserted) {
    return { id: inserted.id, is_duplicate: false };
  }

  // If unique constraint violation (23505), look up existing
  if (insertError?.code === "23505") {
    const { data: existing } = await supabase
      .from("conversions")
      .select("id")
      .eq("idempotency_key", idempotencyKey)
      .single();

    if (existing) {
      return { id: existing.id, is_duplicate: true };
    }
  }

  console.error("[webhook] Failed to create conversion:", insertError?.message);
  return null;
}

/**
 * Update the lead's conversion_status to match the incoming conversion type (OFL-02).
 *
 * Maps: qualified → 'qualified', closed → 'closed'
 */
async function updateLeadStatus(leadId: string, conversionType: "qualified" | "closed") {
  const supabase = createServiceClient();

  const { error } = await supabase
    .from("leads")
    .update({ conversion_status: conversionType })
    .eq("id", leadId);

  if (error) {
    console.error("[webhook] Failed to update lead status:", error.message);
  }
}

/**
 * Main webhook handler (OFL-01, OFL-02, OFL-03, OFL-04).
 *
 * Orchestrates the full flow: validate → parse → match → insert → queue.
 * Always returns 200 to prevent webhook retries on business logic failures.
 */
export async function handleCrmWebhook(
  rawBody: string,
  signature: string | null
): Promise<{ status: number; body: WebhookResult }> {
  // Step 1: Validate signature (OFL-01)
  const secret = process.env.CRM_WEBHOOK_SECRET;
  if (!secret) {
    console.error("[webhook] CRM_WEBHOOK_SECRET not configured");
    return { status: 500, body: { success: false, reason: "server_config_error" } };
  }

  if (!verifyWebhookSignature(rawBody, signature, secret)) {
    return { status: 401, body: { success: false, reason: "invalid_signature" } };
  }

  // Step 2: Parse payload
  let parsed: unknown;
  try {
    parsed = JSON.parse(rawBody);
  } catch {
    return { status: 200, body: { success: false, reason: "invalid_json" } };
  }

  const payload = parsePayload(parsed);
  if (!payload) {
    return { status: 200, body: { success: false, reason: "invalid_payload" } };
  }

  // Step 3: Match lead by email (OFL-02)
  const lead = await matchLeadByEmail(payload.email);
  if (!lead) {
    return { status: 200, body: { success: false, reason: "lead_not_found" } };
  }

  // Step 4: Create conversion record (OFL-03)
  const conversion = await createConversion(payload, lead);
  if (!conversion) {
    return { status: 200, body: { success: false, reason: "conversion_create_failed" } };
  }

  // Step 5: Update lead conversion_status
  await updateLeadStatus(lead.lead_id, payload.conversion_type);

  // Step 6: Queue for Google Ads upload if not duplicate (OFL-04)
  let queued = false;
  if (!conversion.is_duplicate) {
    const queueResult = await createQueueEntry(
      conversion.id,
      lead.gclid,
      lead.email_hash
    );
    queued = queueResult.created;
  }

  return {
    status: 200,
    body: {
      success: true,
      conversion_id: conversion.id,
      queued,
    },
  };
}
```

Key implementation notes:
- HMAC-SHA256 with timing-safe comparison for webhook signature (same crypto pattern as CSRF in csrf.ts)
- Lead matching uses email_hash index (idx_leads_email_hash from migration 005)
- Visitor JOIN to get gclid (leads.visitor_id FK → visitors.gclid)
- INSERT with ON CONFLICT for idempotency (Postgres unique constraint on idempotency_key)
- Queue entry only created for non-duplicate conversions with attribution data
- All business logic failures return 200 to prevent CRM webhook retries
- Only signature failures return 401
- New env var: CRM_WEBHOOK_SECRET
  </action>
  <verify>
Validate file structure:
- Confirm src/lib/conversions/webhook.ts exports verifyWebhookSignature and handleCrmWebhook
- Confirm src/lib/conversions/queue.ts exports createQueueEntry
- Confirm HMAC-SHA256 uses timingSafeEqual from crypto
- Confirm idempotency_key format is `${crm_deal_id}:${conversion_type}`
- Confirm lead matching uses email_hash (not raw email)
- Confirm queue entry checks for gclid OR email_hash before creating
- Run: grep -c "timingSafeEqual" src/lib/conversions/webhook.ts — expect 1
- Run: grep -c "createQueueEntry" src/lib/conversions/webhook.ts — expect 1 (import + call = in file)
  </verify>
  <done>
webhook.ts handles full pipeline: HMAC signature validation (OFL-01), lead matching by email_hash with gclid retrieval via visitor join (OFL-02), idempotent conversion creation (OFL-03).
queue.ts creates queue entries only when attribution data exists (OFL-04).
All business logic failures return HTTP 200 to prevent webhook retries.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create API route handler for CRM webhook</name>
  <files>src/app/api/webhooks/crm-conversion/route.ts</files>
  <action>
Create `src/app/api/webhooks/crm-conversion/route.ts` as a thin route handler:

```typescript
/**
 * CRM Conversion Webhook Endpoint
 *
 * POST /api/webhooks/crm-conversion
 *
 * Receives conversion notifications from NetHunt CRM when a deal
 * reaches qualified or closed status. Validates HMAC signature,
 * matches to lead, creates conversion, and queues for Google Ads upload.
 *
 * Authentication: HMAC-SHA256 signature in X-Webhook-Signature header
 * signed with CRM_WEBHOOK_SECRET.
 *
 * Always returns 200 on valid signature (even if lead not found or
 * duplicate) to prevent CRM webhook retries. Returns 401 only on
 * signature failure.
 */

import { handleCrmWebhook } from "@/lib/conversions/webhook";

export async function POST(request: Request) {
  const rawBody = await request.text();
  const signature = request.headers.get("x-webhook-signature");

  const result = await handleCrmWebhook(rawBody, signature);

  return Response.json(result.body, { status: result.status });
}
```

This follows the established pattern from Phase 3 (lead pipeline hardening) where route files are thin wrappers delegating to service modules. The route file should be minimal — all business logic lives in webhook.ts.

No GET, PUT, DELETE, or other methods exported — only POST is valid for webhook endpoints.
  </action>
  <verify>
- Confirm route.ts exports only POST function
- Confirm it imports handleCrmWebhook from @/lib/conversions/webhook
- Confirm raw body is read via request.text() (not request.json()) — HMAC needs the exact raw string
- Confirm signature is read from x-webhook-signature header
- Run: grep -c "request.text()" src/app/api/webhooks/crm-conversion/route.ts — expect 1
  </verify>
  <done>
Route handler at /api/webhooks/crm-conversion accepts POST, reads raw body for HMAC verification, delegates to handleCrmWebhook. Follows thin-route pattern from Phase 3.
  </done>
</task>

</tasks>

<verification>
1. src/lib/conversions/webhook.ts exists with verifyWebhookSignature and handleCrmWebhook exports
2. src/lib/conversions/queue.ts exists with createQueueEntry export
3. src/app/api/webhooks/crm-conversion/route.ts exists with POST handler
4. HMAC-SHA256 signature verification uses timingSafeEqual (OFL-01)
5. Lead matching queries by email_hash with visitor JOIN for gclid (OFL-02)
6. Idempotency key is {crm_deal_id}:{conversion_type} with UNIQUE constraint handling (OFL-03)
7. Queue entry created only when gclid or email_hash exists (OFL-04)
8. Duplicate webhooks produce no duplicate conversion rows and no duplicate queue entries
9. Business logic failures return 200; signature failures return 401
</verification>

<success_criteria>
- Valid-signature webhook with known email: 200 + conversion created + queue entry created
- Invalid-signature webhook: 401
- Valid webhook with unknown email: 200 + { success: false, reason: "lead_not_found" }
- Duplicate webhook (same crm_deal_id:conversion_type): 200 + { success: true, queued: false }
- Conversion row has denormalized gclid, email_hash, UTMs from matched lead
- Queue entry has status 'pending' and platform 'google_ads'
</success_criteria>

<output>
After completion, create `.planning/phases/10-offline-conversion-pipeline/10-01-SUMMARY.md`
</output>
