---
phase: 04-performance-architecture
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/components/listing-map.tsx
  - src/components/listing-card.tsx
autonomous: true
requirements: [PERF-04, PERF-05]

must_haves:
  truths:
    - "Mapbox GL JS bundle does not load on listing detail page until the map section enters the viewport"
    - "On listing detail page initial load, network tab shows no mapbox-gl request until user scrolls to the map"
    - "ListingCard carousel renders only the first photo's <Image> element on initial load"
    - "Additional carousel photos load only when the user navigates the carousel (clicking next/prev or swiping)"
  artifacts:
    - path: "src/components/listing-map.tsx"
      provides: "Viewport-triggered lazy loading of Mapbox map via IntersectionObserver"
      contains: "IntersectionObserver"
    - path: "src/components/listing-card.tsx"
      provides: "Carousel that renders only visible photo initially, loads others on navigation"
      contains: "current === i || loaded"
  key_links:
    - from: "src/components/listing-map.tsx"
      to: "src/components/listing-map-inner.tsx"
      via: "next/dynamic import triggered by IntersectionObserver"
      pattern: "IntersectionObserver"
    - from: "src/components/listing-card.tsx"
      to: "next/image"
      via: "conditional rendering based on navigation state"
      pattern: "shouldRender"
---

<objective>
Lazy-load Mapbox GL on listing detail pages using viewport detection, and optimize the ListingCard carousel to render only the first photo initially.

Purpose: Mapbox GL JS is ~200KB gzipped. Currently it loads immediately on every listing detail page via `next/dynamic`, even though the map is below the fold. By triggering the dynamic import only when the map section enters the viewport, we eliminate this from initial page load. The carousel currently renders all photos as `<Image>` elements (toggling opacity) — this triggers network requests for all photos. Rendering only the visible photo and loading others on-demand reduces initial network requests.

Output: IntersectionObserver-gated ListingMap component, optimized ImageCarousel with lazy photo rendering.
</objective>

<execution_context>
@/Users/szymonwilkosz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/szymonwilkosz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

<interfaces>
<!-- Key components to modify -->

From src/components/listing-map.tsx (current):
```typescript
"use client";

import dynamic from "next/dynamic";

interface ListingMapProps {
  latitude: number;
  longitude: number;
  name: string;
  address: string;
}

const ListingMapInner = dynamic(() => import("./listing-map-inner"), {
  ssr: false,
  loading: () => (/* spinner */),
});

export function ListingMap(props: ListingMapProps) {
  return <ListingMapInner {...props} />;
}
```

Note: `ListingMapInner` is already loaded via `next/dynamic` with `ssr: false`. The problem is that the dynamic import triggers immediately on component mount. We need to defer it until the container div enters the viewport.

From src/components/listing-card.tsx — ImageCarousel (current):
```typescript
function ImageCarousel({ photos, name }: { photos: string[]; name: string }) {
  const [current, setCurrent] = useState(0);
  // ...
  return (
    <div className="group/carousel relative aspect-[16/10] overflow-hidden">
      {photos.map((photo, i) => (
        <Image
          key={photo}
          src={photo}
          alt={`${name} ${i + 1}`}
          fill
          className={`object-cover transition-opacity duration-300 ${
            i === current ? "opacity-100" : "opacity-0"
          }`}
          sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
          priority={i === 0}
        />
      ))}
      // ... arrows, dots
    </div>
  );
}
```

Problem: All photos are rendered as `<Image>` elements with opacity toggling. Even though only one is visible, the browser requests all images. We need to render only the current photo and any previously-navigated photos.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Lazy-load Mapbox GL via IntersectionObserver on listing detail page</name>
  <files>
    src/components/listing-map.tsx
  </files>
  <action>
    Refactor `src/components/listing-map.tsx` to use IntersectionObserver to detect when the map container enters the viewport, and only THEN render the dynamically-imported ListingMapInner.

    The key insight: `next/dynamic` already handles code-splitting, but the component mounts immediately when the parent renders. By wrapping it in an IntersectionObserver gate, we prevent the dynamic import from executing until the user scrolls to the map section.

    Replace the current implementation with:
    ```typescript
    "use client";

    import { useRef, useState, useEffect } from "react";
    import dynamic from "next/dynamic";

    interface ListingMapProps {
      latitude: number;
      longitude: number;
      name: string;
      address: string;
    }

    const ListingMapInner = dynamic(() => import("./listing-map-inner"), {
      ssr: false,
      loading: () => (
        <div className="relative flex h-full w-full items-center justify-center rounded-lg bg-slate-100">
          <div className="absolute inset-0 rounded-lg opacity-[0.03]" style={{ backgroundImage: "radial-gradient(circle, #000 1px, transparent 1px)", backgroundSize: "24px 24px" }} />
          <div className="z-10 flex flex-col items-center gap-2">
            <div className="h-5 w-5 animate-spin rounded-full border-2 border-slate-300 border-t-slate-600" />
            <p className="text-sm text-muted-text">Karte wird geladen…</p>
          </div>
        </div>
      ),
    });

    export function ListingMap(props: ListingMapProps) {
      const containerRef = useRef<HTMLDivElement>(null);
      const [inView, setInView] = useState(false);

      useEffect(() => {
        const el = containerRef.current;
        if (!el) return;

        const observer = new IntersectionObserver(
          ([entry]) => {
            if (entry.isIntersecting) {
              setInView(true);
              observer.disconnect(); // Only need to trigger once
            }
          },
          {
            rootMargin: "200px", // Start loading 200px before entering viewport
          }
        );

        observer.observe(el);
        return () => observer.disconnect();
      }, []);

      return (
        <div ref={containerRef} style={{ minHeight: inView ? undefined : 560 }}>
          {inView ? (
            <ListingMapInner {...props} />
          ) : (
            <div className="relative flex items-center justify-center rounded-lg bg-slate-100" style={{ height: 560 }}>
              <div className="absolute inset-0 rounded-lg opacity-[0.03]" style={{ backgroundImage: "radial-gradient(circle, #000 1px, transparent 1px)", backgroundSize: "24px 24px" }} />
              <p className="z-10 text-sm text-muted-text">Karte wird beim Scrollen geladen…</p>
            </div>
          )}
        </div>
      );
    }
    ```

    Key design decisions:
    - `rootMargin: "200px"` starts loading the map 200px before it enters the viewport — gives time for the ~200KB Mapbox bundle to download before the user reaches it.
    - `minHeight: 560` on the container prevents layout shift when the map loads.
    - The placeholder mimics the existing loading skeleton pattern used throughout the codebase.
    - Once `inView` is true, it stays true (observer disconnects) — no re-triggering.
    - The existing `ListingMapInner` component is NOT modified — only the wrapper changes.
  </action>
  <verify>
    <automated>
      cd /Users/szymonwilkosz/Library/Mobile\ Documents/com~apple~CloudDocs/claude-config/projects/next-office && grep -c "IntersectionObserver" src/components/listing-map.tsx && grep -c "inView" src/components/listing-map.tsx && grep -c "rootMargin" src/components/listing-map.tsx && echo "ALL LAZY MAP CHECKS PASSED"
    </automated>
  </verify>
  <done>
    - ListingMap uses IntersectionObserver to detect viewport entry
    - Mapbox GL dynamic import only triggers when map section is 200px from viewport
    - Placeholder with correct height shown before map loads (no layout shift)
    - Observer disconnects after first trigger (no ongoing observation)
  </done>
</task>

<task type="auto">
  <name>Task 2: Optimize ListingCard carousel to render only visible photo</name>
  <files>
    src/components/listing-card.tsx
  </files>
  <action>
    Refactor the `ImageCarousel` component inside `src/components/listing-card.tsx` to render only photos that have been navigated to, instead of rendering all photos with opacity toggling.

    Current problem: The carousel renders ALL photos as `<Image>` elements and uses CSS opacity to show/hide them. Even with Next.js Image optimization, the browser still requests all image URLs on initial render.

    Solution: Track which photos have been "loaded" (navigated to). Only render the `<Image>` for the current photo and any previously-visited photos (to preserve smooth opacity transitions when navigating back).

    Replace the ImageCarousel function:
    ```typescript
    function ImageCarousel({ photos, name }: { photos: string[]; name: string }) {
      const [current, setCurrent] = useState(0);
      // Track which photos have been navigated to (for preloading visited ones)
      const [loaded, setLoaded] = useState<Set<number>>(() => new Set([0]));
      const total = photos.length;
      const touchStart = useRef<number | null>(null);
      const touchDelta = useRef(0);

      const goTo = useCallback((index: number) => {
        setCurrent(index);
        setLoaded((prev) => {
          if (prev.has(index)) return prev;
          const next = new Set(prev);
          next.add(index);
          return next;
        });
      }, []);

      const prev = useCallback((e: React.MouseEvent) => {
        e.preventDefault();
        e.stopPropagation();
        goTo(current === 0 ? total - 1 : current - 1);
      }, [current, total, goTo]);

      const next = useCallback((e: React.MouseEvent) => {
        e.preventDefault();
        e.stopPropagation();
        goTo(current === total - 1 ? 0 : current + 1);
      }, [current, total, goTo]);

      const onTouchStart = useCallback((e: React.TouchEvent) => {
        touchStart.current = e.touches[0].clientX;
        touchDelta.current = 0;
      }, []);

      const onTouchMove = useCallback((e: React.TouchEvent) => {
        if (touchStart.current === null) return;
        touchDelta.current = e.touches[0].clientX - touchStart.current;
      }, []);

      const onTouchEnd = useCallback((e: React.TouchEvent) => {
        if (Math.abs(touchDelta.current) > 40) {
          e.preventDefault();
          if (touchDelta.current < 0) {
            goTo(current === total - 1 ? current : current + 1);
          } else {
            goTo(current === 0 ? current : current - 1);
          }
        }
        touchStart.current = null;
        touchDelta.current = 0;
      }, [current, total, goTo]);

      return (
        <div
          className="group/carousel relative aspect-[16/10] overflow-hidden"
          onTouchStart={onTouchStart}
          onTouchMove={onTouchMove}
          onTouchEnd={onTouchEnd}
        >
          {photos.map((photo, i) => {
            // Only render Image elements for the current photo and previously navigated ones
            const shouldRender = loaded.has(i);
            if (!shouldRender) return null;

            return (
              <Image
                key={photo}
                src={photo}
                alt={`${name} ${i + 1}`}
                fill
                className={`object-cover transition-opacity duration-300 ${
                  i === current ? "opacity-100" : "opacity-0"
                }`}
                sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
                priority={i === 0}
              />
            );
          })}

          {/* Arrows — desktop only */}
          {total > 1 && (
            <>
              <button
                onClick={prev}
                className={`absolute left-2 top-1/2 z-10 hidden h-7 w-7 -translate-y-1/2 items-center justify-center rounded-full bg-white/90 shadow-sm transition-opacity hover:bg-white lg:flex ${
                  current === 0 ? "opacity-0" : "opacity-0 group-hover/carousel:opacity-100"
                }`}
                aria-label="Vorheriges Bild"
              >
                <ChevronLeft className="h-4 w-4 text-slate-700" />
              </button>
              <button
                onClick={next}
                className={`absolute right-2 top-1/2 z-10 hidden h-7 w-7 -translate-y-1/2 items-center justify-center rounded-full bg-white/90 shadow-sm transition-opacity hover:bg-white lg:flex ${
                  current === total - 1 ? "opacity-0" : "opacity-0 group-hover/carousel:opacity-100"
                }`}
                aria-label="Nächstes Bild"
              >
                <ChevronRight className="h-4 w-4 text-slate-700" />
              </button>
            </>
          )}

          {/* Dots */}
          {total > 1 && (
            <div className="absolute bottom-2 left-1/2 z-10 flex -translate-x-1/2 gap-1">
              {photos.slice(0, 5).map((_, i) => (
                <span
                  key={i}
                  className={`h-1.5 w-1.5 rounded-full transition-colors ${
                    i === current ? "bg-white" : "bg-white/50"
                  }`}
                />
              ))}
            </div>
          )}
        </div>
      );
    }
    ```

    Key changes from current implementation:
    1. Added `loaded` state (Set of visited indices, initialized with `[0]`)
    2. Added `goTo` function that updates both `current` and `loaded`
    3. Changed `prev`/`next`/touch handlers to use `goTo` instead of direct `setCurrent`
    4. In the render loop: `if (!shouldRender) return null` — only renders Image for visited photos
    5. First photo always renders (index 0 is in the initial Set)
    6. Previously-visited photos stay rendered (for smooth back-navigation transitions)

    **IMPORTANT**: The touch handler callbacks need `current` in their dependency arrays since they reference it. The original code used `setCurrent(c => ...)` pattern — the new code uses `goTo(current +/- 1)` which reads `current` directly. This is intentional to ensure `loaded` stays in sync.
  </action>
  <verify>
    <automated>
      cd /Users/szymonwilkosz/Library/Mobile\ Documents/com~apple~CloudDocs/claude-config/projects/next-office && grep -c "shouldRender" src/components/listing-card.tsx && grep -c "loaded" src/components/listing-card.tsx && grep -c "new Set" src/components/listing-card.tsx && echo "ALL CAROUSEL CHECKS PASSED"
    </automated>
  </verify>
  <done>
    - ImageCarousel renders only the first photo on initial load (index 0)
    - Additional photos render only when user navigates to them (click or swipe)
    - Previously-navigated photos stay rendered for smooth back-navigation
    - Arrow and dot UI unchanged
    - Network tab on initial page load shows only 1 image request per carousel (not all photos)
  </done>
</task>

</tasks>

<verification>
1. `grep "IntersectionObserver" src/components/listing-map.tsx` confirms viewport-gated loading
2. `grep "shouldRender" src/components/listing-card.tsx` confirms conditional photo rendering
3. On a listing detail page, opening browser Network tab and loading the page shows no mapbox-gl request until scrolling to the map section
4. On a search/city page, inspecting DOM of a ListingCard shows only 1 rendered `<img>` element initially (not all photos)
</verification>

<success_criteria>
- Mapbox GL bundle does not load until map section enters viewport (200px margin)
- ListingCard carousel renders only 1 photo on initial load
- No visual regressions — carousel navigation works, map loads when scrolled to
- Map placeholder has correct height to prevent layout shift
</success_criteria>

<output>
After completion, create `.planning/phases/04-performance-architecture/04-03-SUMMARY.md`
</output>
