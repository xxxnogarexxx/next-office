---
phase: 08-visitor-utm-capture
plan: 03
type: execute
wave: 2
depends_on:
  - "08-01"
files_modified:
  - src/lib/leads/supabase.ts
  - src/lib/leads/service.ts
  - src/components/lp/tracking/lp-tracking-provider.tsx
autonomous: true
requirements:
  - CAP-04
  - CAP-05

must_haves:
  truths:
    - "insertLead() writes visitor_id (UUID, resolved from _no_vid cookie) to the leads table"
    - "insertLead() writes utm_source, utm_medium, utm_campaign, utm_term, utm_content to the leads table"
    - "UTM values come from cookies (_no_utm_*) set by middleware, not from the client request body"
    - "visitor_id resolves to the UUID from the visitors table (via a SELECT on visitor_id text → id UUID)"
    - "A lead row created after form submission contains a non-null visitor_id FK pointing to the visitors row"
    - "A lead row contains non-null UTM values when the user arrived with UTM parameters"
  artifacts:
    - path: "src/lib/leads/supabase.ts"
      provides: "insertLead() extended to write visitor_id UUID FK and 5 UTM columns to leads table"
      contains: "visitor_id"
    - path: "src/lib/leads/service.ts"
      provides: "handleLeadSubmission() extended to resolve visitor_id UUID from cookie, pass UTMs from cookies to insertLead"
      contains: "visitor_id"
    - path: "src/components/lp/tracking/lp-tracking-provider.tsx"
      provides: "Client-side provider that fires POST /api/track/visit on page load"
      contains: "track/visit"
  key_links:
    - from: "src/lib/leads/supabase.ts"
      to: "supabase/migrations/005_leads_extension.sql"
      via: "writes visitor_id FK and UTM columns added by migration 005"
      pattern: "visitor_id"
    - from: "src/lib/leads/service.ts"
      to: "src/lib/leads/supabase.ts"
      via: "passes resolved visitor_id UUID and UTM values to insertLead"
      pattern: "visitor_id"
---

<objective>
Wire visitor_id and UTM attribution into the lead submission pipeline (CAP-04, CAP-05):
1. When a lead form is submitted, the API reads the _no_vid cookie, resolves it to the UUID primary key in the visitors table, and stores it as visitor_id FK in the leads table.
2. UTM values from _no_utm_* cookies are read server-side and stored in the leads table alongside the lead.
3. A client-side tracking provider fires POST /api/track/visit on LP page load so the visitor row exists in Supabase before the lead form is submitted.

This plan does NOT introduce changes to the form UI — all changes are server-side (service.ts, supabase.ts) and in the LP layout provider.
</objective>

<execution_context>
@/Users/szymonwilkosz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/szymonwilkosz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-visitor-utm-capture/08-01-SUMMARY.md
@.planning/phases/08-visitor-utm-capture/08-02-SUMMARY.md
@src/middleware.ts
@src/lib/tracking/visitor.ts
@src/lib/leads/service.ts
@src/lib/leads/supabase.ts
@src/lib/leads/validation.ts
@src/components/lp/tracking/lp-tracking-provider.tsx
@supabase/migrations/001_visitors.sql
@supabase/migrations/005_leads_extension.sql

Leads table columns added by migration 005 (ready to receive data):
- visitor_id UUID REFERENCES visitors(id) ON DELETE SET NULL — nullable FK
- utm_source, utm_medium, utm_campaign, utm_term, utm_content TEXT

Current insertLead() (src/lib/leads/supabase.ts):
- Does NOT write visitor_id, utm_source, utm_medium, utm_campaign, utm_term, utm_content
- These columns exist in ValidatedLeadData but are not written to Supabase

Current handleLeadSubmission() (src/lib/leads/service.ts):
- Reads _no_gclid, _no_gbraid, _no_wbraid cookies as fallback
- Does NOT read _no_vid or _no_utm_* cookies

Visitor_id resolution challenge:
- The _no_vid cookie stores a TEXT value (UUID string, e.g. "a1b2c3d4-...")
- The leads table stores visitor_id as UUID (the PK `id` column of visitors, not visitor_id TEXT column)
- Need to resolve: _no_vid TEXT → visitors.id UUID
- Do a SELECT on visitors WHERE visitor_id = _no_vid_cookie_value → get id UUID → use as FK

This resolution MUST be done server-side in the API route (service.ts or supabase.ts).
Uses the service role client (visitors table has no anon read RLS policy either).

UTM source of truth:
- Cookies (_no_utm_*) are the authoritative source for UTMs at lead submission time.
- ValidatedLeadData already includes utm_source etc. (the form sends them in the body too).
- At submission time: prefer cookie values, fall back to body values (same pattern as gclid fallback).
- This ensures UTMs are captured even if the client form didn't include them in the body.

lp-tracking-provider.tsx:
- Currently exists (Phase 6 tracking infrastructure)
- Must call POST /api/track/visit on mount to record the visitor session in Supabase
- This ensures visitors table has a row for the visitor before the lead is submitted
- The call is fire-and-forget — failures must not affect page loading or form submission
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend insertLead() to write visitor_id UUID FK and UTM columns</name>
  <files>src/lib/leads/supabase.ts</files>
  <action>
Edit `src/lib/leads/supabase.ts`:

1. Add `visitorUuid` and the 5 UTM fields to the `insertLead()` call.
2. Add `resolveVisitorUuid()` — a helper that takes a visitor_id TEXT value (from cookie) and returns the UUID primary key from the visitors table.

**Add resolveVisitorUuid() function:**

```typescript
/**
 * Resolves a visitor_id text value (from cookie) to the UUID primary key
 * of the visitors table row.
 *
 * Returns null if:
 * - visitorIdText is null/undefined (no cookie)
 * - No visitors row found with that visitor_id (race condition or stale cookie)
 * - Supabase query fails (non-fatal — lead is created without visitor FK)
 *
 * Uses service role client — visitors table has no anon SELECT RLS policy.
 */
export async function resolveVisitorUuid(
  visitorIdText: string | null
): Promise<string | null> {
  if (!visitorIdText) return null;

  // Import service client (or create it inline — must use service role)
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
  if (!url || !serviceRoleKey) return null;

  const { createClient } = await import("@supabase/supabase-js");
  const client = createClient(url, serviceRoleKey, {
    auth: { persistSession: false },
  });

  const { data, error } = await client
    .from("visitors")
    .select("id")
    .eq("visitor_id", visitorIdText)
    .single();

  if (error || !data?.id) {
    // Non-fatal: log and return null. Lead insert will proceed without visitor FK.
    if (error && error.code !== "PGRST116") {
      // PGRST116 = "no rows found" — not an error, just a new visitor
      console.error("[leads/supabase] resolveVisitorUuid error:", error);
    }
    return null;
  }

  return data.id as string;
}
```

**Extend insertLead() to accept and write visitor_id and UTM columns:**

Update the function signature to include `visitor_id` and UTM params. The `ValidatedLeadData` interface already has `utm_source` etc., but `visitor_id` (the UUID) is not in `ValidatedLeadData` (that stores the cookie text, not the resolved UUID). Add an optional `visitorUuid` parameter:

Option A: Add `visitorUuid?: string | null` as a separate parameter to `insertLead()`.
Option B: Add `visitorUuid` to the data object passed into `insertLead()`.

**Use Option B** — extend the insert call with a second argument or add visitorUuid to the data shape:

Change `insertLead(data: ValidatedLeadData)` signature to accept visitorUuid as second param:

```typescript
export async function insertLead(
  data: ValidatedLeadData,
  visitorUuid?: string | null
): Promise<{ success: true } | { success: false; error: string }> {
  const client = createScopedClient(); // anon client is fine for leads INSERT (RLS allows anon insert)

  const { error } = await client.from("leads").insert({
    // existing fields
    name: data.name,
    email: data.email,
    phone: data.phone,
    team_size: data.team_size,
    start_date: data.start_date,
    city: data.city,
    message: data.message,
    listing_id: data.listing_id,
    listing_name: data.listing_name,
    gclid: data.gclid,
    gbraid: data.gbraid,
    wbraid: data.wbraid,
    landing_page: data.landing_page,
    referrer: data.referrer,
    // NEW: visitor attribution (CAP-04)
    visitor_id: visitorUuid ?? null,
    // NEW: UTM columns (CAP-05)
    utm_source: data.utm_source,
    utm_medium: data.utm_medium,
    utm_campaign: data.utm_campaign,
    utm_term: data.utm_term,
    utm_content: data.utm_content,
  });

  if (error) {
    console.error("[leads/supabase] insertLead error:", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}
```
  </action>
  <verify>
- Run: `grep "visitor_id\|utm_source\|utm_medium" src/lib/leads/supabase.ts` — expect multiple matches
- Run: `grep "resolveVisitorUuid" src/lib/leads/supabase.ts` — expect match
- Run: `grep "visitorUuid" src/lib/leads/supabase.ts` — expect match in insertLead signature and body
- Confirm anon client still used for insertLead (leads RLS allows anon insert): `grep "createScopedClient" src/lib/leads/supabase.ts`
- TypeScript check: `npx tsc --noEmit`
  </verify>
  <done>
src/lib/leads/supabase.ts extended with:
- resolveVisitorUuid(visitorIdText): looks up visitors table by visitor_id text, returns UUID id column
- insertLead() signature extended with optional visitorUuid param
- insertLead() writes visitor_id UUID FK and all 5 UTM columns to leads table
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend handleLeadSubmission() to resolve visitor_id and pass UTMs from cookies</name>
  <files>src/lib/leads/service.ts</files>
  <action>
Edit `src/lib/leads/service.ts`:

In `handleLeadSubmission()`, after Step 5 (cookie resolution), add:

**Step 5b: Resolve visitor UUID from _no_vid cookie**

```typescript
// Step 5b: Resolve visitor_id cookie to UUID primary key in visitors table.
// The _no_vid cookie holds the TEXT visitor_id value. We need the UUID `id`
// column from the visitors table row to use as FK in leads.
// Non-fatal: if resolution fails, lead is inserted without visitor FK.
const visitorIdText = cookieStore.get("_no_vid")?.value ?? null;
const visitorUuid = await resolveVisitorUuid(visitorIdText);
```

**Step 5c: Merge UTM cookie values into resolvedData**

The existing service.ts already reads UTM values from the request body (via `validateLeadPayload()`). Add cookie-based UTM fallback — same pattern as gclid:

```typescript
// Step 5c: Merge UTM values from cookies as authoritative source.
// Cookies (set by middleware on landing) are preferred over body values
// because the client may not always send UTMs in the body (e.g., return visits).
const utm_source =
  cookieStore.get("_no_utm_source")?.value || data.utm_source || null;
const utm_medium =
  cookieStore.get("_no_utm_medium")?.value || data.utm_medium || null;
const utm_campaign =
  cookieStore.get("_no_utm_campaign")?.value || data.utm_campaign || null;
const utm_term =
  cookieStore.get("_no_utm_term")?.value || data.utm_term || null;
const utm_content =
  cookieStore.get("_no_utm_content")?.value || data.utm_content || null;

// Merge into resolvedData
const resolvedData = {
  ...data,
  gclid,
  gbraid,
  wbraid,
  landing_page,
  referrer,
  utm_source,
  utm_medium,
  utm_campaign,
  utm_term,
  utm_content,
};
```

**Update Step 7 (insertLead call)** to pass visitorUuid:

```typescript
// Step 7: Insert lead into Supabase
const insertResult = await insertLead(resolvedData, visitorUuid);
```

**Import resolveVisitorUuid** at the top of service.ts:

```typescript
import { checkDuplicate, insertLead, resolveVisitorUuid } from "./supabase";
```

**Placement in handleLeadSubmission() pipeline:**
- Steps 1-5 unchanged (rate limit, parse, CSRF, validate, gclid cookies)
- Step 5b: resolve visitorUuid (new, after step 5)
- Step 5c: merge UTM cookies (new, replaces/extends existing resolvedData construction)
- Steps 6-9 unchanged (dedup, insert, email, return) — except step 7 passes visitorUuid
  </action>
  <verify>
- Run: `grep "resolveVisitorUuid\|visitorUuid\|_no_vid" src/lib/leads/service.ts` — expect matches
- Run: `grep "_no_utm_source\|_no_utm_medium" src/lib/leads/service.ts` — expect matches
- Run: `grep "insertLead(resolvedData, visitorUuid)" src/lib/leads/service.ts` — expect match
- Run: `grep "import.*resolveVisitorUuid" src/lib/leads/service.ts` — expect match
- TypeScript check: `npx tsc --noEmit` — expect no errors
  </verify>
  <done>
src/lib/leads/service.ts extended with:
- Import of resolveVisitorUuid from ./supabase
- Step 5b: reads _no_vid cookie, calls resolveVisitorUuid() to get UUID
- Step 5c: reads _no_utm_* cookies as authoritative UTM source (falls back to body values)
- Step 7: passes visitorUuid as second argument to insertLead()
All existing pipeline steps (rate limit, CSRF, validation, dedup, email) unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add visit tracking call to LP tracking provider</name>
  <files>src/components/lp/tracking/lp-tracking-provider.tsx</files>
  <action>
Edit `src/components/lp/tracking/lp-tracking-provider.tsx`.

Read the current contents of this file first, then add a useEffect that fires POST /api/track/visit on mount.

The visit tracking call must:
1. Fire on component mount (useEffect with empty deps [])
2. Be fire-and-forget — errors are swallowed with a console.error
3. Not block rendering or form interaction

Add the following effect inside the component (or create the component if it doesn't exist with a client-side tracking hook):

```typescript
// Fire visit tracking on page load — records visitor session in Supabase.
// Runs once per page load. Errors are non-fatal (tracking must not break UX).
useEffect(() => {
  fetch("/api/track/visit", {
    method: "POST",
    credentials: "same-origin",
  }).catch((err) => {
    console.error("[lp-tracking] visit tracking failed:", err);
  });
}, []);
```

If `lp-tracking-provider.tsx` already has useEffect imports and is a "use client" component, simply add this effect inside the existing component body. Do not duplicate existing effects.

If the component does not currently use `useEffect`, import it: `import { useEffect } from "react";`

The visit tracking call is placed in the LP tracking provider (not the main site) because:
- Phase 8 focuses on LP visitors (Google Ads traffic lands on /lp/[city])
- The main site tracking provider (src/components/tracking-provider.tsx) is separate — do NOT modify it in this plan
- Future phases can extend main site tracking

Read src/components/lp/tracking/lp-tracking-provider.tsx before editing to understand its current structure. Preserve all existing tracking behavior (scroll tracking, GTM, etc.).
  </action>
  <verify>
- Run: `grep "track/visit\|api/track" src/components/lp/tracking/lp-tracking-provider.tsx` — expect match
- Run: `grep "useEffect" src/components/lp/tracking/lp-tracking-provider.tsx` — expect match
- Confirm "use client" directive present: `grep "use client" src/components/lp/tracking/lp-tracking-provider.tsx`
- TypeScript check: `npx tsc --noEmit`
  </verify>
  <done>
src/components/lp/tracking/lp-tracking-provider.tsx extended with:
- useEffect on mount that fires POST /api/track/visit (fire-and-forget)
- Errors caught and logged to console.error — tracking failures do not affect UX
- All existing tracking behavior (scroll, GTM) preserved
  </done>
</task>

</tasks>

<verification>
1. insertLead() in supabase.ts writes visitor_id UUID and all 5 UTM columns to the leads table
2. resolveVisitorUuid() SELECT query uses service role client (visitors has no anon read RLS)
3. handleLeadSubmission() in service.ts reads _no_vid cookie and calls resolveVisitorUuid()
4. handleLeadSubmission() reads _no_utm_* cookies and merges them into resolvedData before insert
5. Cookie values take priority over body values for UTMs (same as gclid pattern)
6. insertLead() is called with visitorUuid as second argument
7. lp-tracking-provider.tsx fires POST /api/track/visit on mount
8. npx tsc --noEmit passes with no type errors
</verification>

<success_criteria>
- Submitting the LP lead form creates a leads row with visitor_id FK pointing to the visitors table row (CAP-04)
- The leads row contains utm_source, utm_medium, utm_campaign, utm_term, utm_content from cookies (CAP-05)
- The visitor_id FK is a UUID (resolved from the TEXT visitor_id cookie via visitors table lookup)
- lp-tracking-provider fires POST /api/track/visit on page load ensuring visitor row exists before form submit
- No TypeScript errors
- All existing lead form behavior (validation, CSRF, dedup, email notification) unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/08-visitor-utm-capture/08-03-SUMMARY.md`
</output>
