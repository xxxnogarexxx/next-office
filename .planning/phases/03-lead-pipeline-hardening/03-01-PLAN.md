---
phase: 03-lead-pipeline-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/leads/validation.ts
  - src/lib/leads/csrf.ts
  - src/lib/leads/supabase.ts
  - src/lib/leads/email.ts
  - src/lib/leads/service.ts
autonomous: true
requirements:
  - SEC-07
  - SEC-08
  - SEC-09
  - SEC-10
  - SEC-11
  - REL-04
  - REL-05
  - REL-06

must_haves:
  truths:
    - "A shared lead service module exists that both /api/leads and /api/lp-leads can import"
    - "Email validation rejects invalid formats like 'hello' or '@.@' on both routes"
    - "Cookie values (gclid/gbraid/wbraid) are validated for format and max length"
    - "Lead request bodies are validated for field types and input size limits"
    - "A CSRF token generation and verification mechanism exists for lead form protection"
    - "Supabase lead inserts use a scoped anon key instead of the service role key"
    - "Duplicate lead detection by phone + city prevents redundant DB inserts"
    - "Email sending is wrapped in a non-blocking utility that does not delay the API response"
  artifacts:
    - path: "src/lib/leads/validation.ts"
      provides: "Input validation for lead payloads — email, body size, field types, cookie format"
      exports: ["validateLeadPayload", "validateEmail", "validateCookieValue"]
    - path: "src/lib/leads/csrf.ts"
      provides: "CSRF token generation and verification using HMAC-SHA256"
      exports: ["generateCsrfToken", "verifyCsrfToken"]
    - path: "src/lib/leads/supabase.ts"
      provides: "Scoped Supabase client for lead inserts + duplicate detection"
      exports: ["insertLead", "checkDuplicate"]
    - path: "src/lib/leads/email.ts"
      provides: "Non-blocking email notification builder and sender"
      exports: ["sendLeadNotification", "escapeHtml"]
    - path: "src/lib/leads/service.ts"
      provides: "Orchestrator that composes validation, CSRF, insert, dedup, and email"
      exports: ["handleLeadSubmission"]
  key_links:
    - from: "src/lib/leads/service.ts"
      to: "src/lib/leads/validation.ts"
      via: "import validateLeadPayload"
      pattern: "import.*from.*leads/validation"
    - from: "src/lib/leads/service.ts"
      to: "src/lib/leads/supabase.ts"
      via: "import insertLead, checkDuplicate"
      pattern: "import.*from.*leads/supabase"
    - from: "src/lib/leads/service.ts"
      to: "src/lib/leads/email.ts"
      via: "import sendLeadNotification"
      pattern: "import.*from.*leads/email"
    - from: "src/lib/leads/service.ts"
      to: "src/lib/leads/csrf.ts"
      via: "import verifyCsrfToken"
      pattern: "import.*from.*leads/csrf"
---

<objective>
Create a consolidated lead service library that centralizes all lead pipeline logic — validation, CSRF protection, scoped DB access, duplicate detection, and non-blocking email — into a single shared module consumed by both lead API routes.

Purpose: Eliminate code duplication between /api/leads and /api/lp-leads, implement all missing security controls (CSRF, email validation, input size limits, cookie validation, scoped Supabase access), add duplicate lead detection, and ensure email sending never blocks the API response path.

Output: A `src/lib/leads/` module with 5 files — validation.ts, csrf.ts, supabase.ts, email.ts, service.ts — providing a single `handleLeadSubmission()` entry point.
</objective>

<execution_context>
@/Users/szymonwilkosz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/szymonwilkosz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/app/(main)/api/leads/route.ts
@src/app/(lp)/api/lp-leads/route.ts
@src/middleware.ts
@src/lib/env.ts

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/lib/types.ts:
```typescript
export interface Listing { /* ... */ }
export interface City { name: string; slug: string; /* ... */ }
```

From src/lib/env.ts:
```typescript
export type ValidatedEnv = { NEXT_PUBLIC_SUPABASE_URL: string; SUPABASE_SERVICE_ROLE_KEY: string; RESEND_API_KEY: string; NOTIFICATION_EMAIL: string; NEXT_PUBLIC_MAPBOX_ACCESS_TOKEN: string; /* optional GA/Ads vars */ };
export const env: ValidatedEnv;
```

From src/middleware.ts:
```typescript
// CORS + tracking cookie middleware
// Tracking cookies: _no_gclid, _no_gbraid, _no_wbraid, _no_lp, _no_ref
// Cookie values come from URL search params without validation
```

Both route files currently:
- Use SUPABASE_SERVICE_ROLE_KEY (needs scoped access)
- Duplicate escapeHtml(), checkRateLimit(), rateLimitMap
- Main route: no email validation at all
- LP route: basic /^[^\s@]+@[^\s@]+\.[^\s@]+$/ email regex
- Neither validates cookie values or request body sizes
- Neither checks for duplicate leads
- Both use fire-and-forget .catch() for email (adequate but could be cleaner)
- No CSRF token mechanism exists anywhere
</interfaces>

**Key decisions from prior phases:**
- escapeHtml duplicated per-file — consolidation deferred to THIS phase (REL-04)
- Rate limiter: 10 req/min/IP, in-memory Map — keep this pattern, but in shared module
- Error responses use generic German messages — maintain this pattern
- env.ts uses zero external dependencies — validation.ts should follow same pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lead validation, CSRF, and scoped Supabase modules</name>
  <files>
    src/lib/leads/validation.ts
    src/lib/leads/csrf.ts
    src/lib/leads/supabase.ts
  </files>
  <action>
Create three files in `src/lib/leads/`:

**validation.ts** — Input validation for lead payloads (SEC-08, SEC-09, SEC-11):
- `validateEmail(email: string): boolean` — RFC-compliant email check. Use pattern: `/^[^\s@]+@[^\s@]+\.[^\s@]+$/` as baseline but also reject edge cases like `a@.b`, `@foo.bar`, `a@b.` — the regex should require at least 1 char before @, domain part has at least one dot with chars on both sides. Use: `/^[a-zA-Z0-9.!#$%&'*+/=?^_\`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*\.[a-zA-Z]{2,}$/` for RFC 5322 simplified compliance.
- `validateCookieValue(value: string | null | undefined): string | null` — Returns sanitized value or null. Rules: max 150 chars, alphanumeric plus hyphens/underscores/dots only (covers gclid/gbraid/wbraid formats which are base64-ish strings). Rejects values containing `<`, `>`, `"`, `'`, or any non-printable characters.
- `validateLeadPayload(body: unknown): { valid: true; data: ValidatedLeadData } | { valid: false; error: string }` — Type guard that validates the full request body:
  - body must be a non-null object
  - Total JSON body size max 10KB (reject oversized payloads before parsing fields)
  - `name`: required string, 1-200 chars, trimmed
  - `email`: required string, must pass validateEmail
  - `phone`: optional string, max 50 chars
  - `team_size`: optional, if present must be a positive integer (1-10000)
  - `start_date`: optional string, must be ISO date format if present
  - `city`: optional string, max 100 chars
  - `message`: optional string, max 5000 chars
  - `listing_id`: optional string, max 100 chars
  - `listing_name`: optional string, max 200 chars
  - `company`: optional string, max 200 chars
  - UTM fields (utm_source, utm_medium, utm_campaign, utm_term, utm_content): optional strings, max 200 chars each
  - Tracking fields (gclid, gbraid, wbraid): pass through validateCookieValue
  - `landing_page`: optional string, max 2000 chars
  - `referrer`: optional string, max 2000 chars
- Export `ValidatedLeadData` interface with all validated fields typed (no `any`)
- Zero external dependencies (plain TypeScript like env.ts)

**csrf.ts** — CSRF token mechanism (SEC-07):
- Use the double-submit cookie pattern (stateless, no server-side session needed):
  - `generateCsrfToken(): { token: string; cookieValue: string }` — generates a random token (32 bytes hex via `crypto.randomBytes`), returns the token (to embed in form/response) and a cookie value (HMAC-SHA256 of the token using `SUPABASE_SERVICE_ROLE_KEY` as the secret — this key is already available and never exposed to the client)
  - `verifyCsrfToken(token: string | null, cookieValue: string | null): boolean` — recomputes HMAC of the token and compares to cookie value using `crypto.timingSafeEqual`. Returns false if either is missing/empty.
- Import `crypto` from Node.js standard library (available in Next.js server context)
- IMPORTANT: The CSRF secret should be a separate env var ideally, but to avoid adding new required env vars, derive it from `process.env.SUPABASE_SERVICE_ROLE_KEY` (which is already server-only and never exposed to the client). Document this decision in a comment.
- Export `CSRF_COOKIE_NAME = "_no_csrf"` constant for consistent cookie naming.

**supabase.ts** — Scoped database access + duplicate detection (SEC-10, REL-06):
- `createScopedClient()` — Creates a Supabase client using `NEXT_PUBLIC_SUPABASE_URL` and `NEXT_PUBLIC_SUPABASE_ANON_KEY` (the anon key, NOT the service role key). Add `NEXT_PUBLIC_SUPABASE_ANON_KEY` to the env validation module — it is already a NEXT_PUBLIC_ var meaning it's safe for client exposure and suitable for scoped access.
  - IMPORTANT: The anon key works because Supabase Row Level Security (RLS) policies on the `leads` table must allow inserts. The executor should add a comment noting that RLS must be configured in the Supabase dashboard to allow anon inserts on the leads table.
- `checkDuplicate(phone: string, city: string): Promise<boolean>` — Queries the leads table for an existing lead with the same phone AND city created within the last 24 hours (configurable constant `DEDUP_WINDOW_MS = 24 * 60 * 60 * 1000`). Returns true if a duplicate exists. Uses a `.select('id').eq('phone', phone).eq('city', city).gte('created_at', windowStart).limit(1)` query.
- `insertLead(data: ValidatedLeadData): Promise<{ success: true } | { success: false; error: string }>` — Inserts into the leads table using the scoped client. Maps ValidatedLeadData fields to the DB columns.
- Import ValidatedLeadData from validation.ts.

NOTE for executor: `NEXT_PUBLIC_SUPABASE_ANON_KEY` must be added to:
1. `src/lib/env.ts` — add to REQUIRED_SERVER array
2. `.env.example` — add with description
3. The `env` type must be updated
  </action>
  <verify>
    <automated>cd /Users/szymonwilkosz/Library/Mobile\ Documents/com~apple~CloudDocs/claude-config/projects/next-office && npx tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>
    - src/lib/leads/validation.ts exports validateEmail, validateCookieValue, validateLeadPayload, and ValidatedLeadData type
    - src/lib/leads/csrf.ts exports generateCsrfToken, verifyCsrfToken, and CSRF_COOKIE_NAME
    - src/lib/leads/supabase.ts exports createScopedClient, checkDuplicate, insertLead
    - NEXT_PUBLIC_SUPABASE_ANON_KEY added to env.ts and .env.example
    - All files use zero external dependencies beyond @supabase/supabase-js (already installed) and Node.js crypto
    - npx tsc --noEmit passes without errors in these files
  </done>
</task>

<task type="auto">
  <name>Task 2: Create shared email utility and lead service orchestrator</name>
  <files>
    src/lib/leads/email.ts
    src/lib/leads/service.ts
  </files>
  <action>
Create two files in `src/lib/leads/`:

**email.ts** — Non-blocking email notification (REL-04, REL-05):
- Move `escapeHtml()` here as the single source of truth (eliminating duplication from both route files)
- `escapeHtml(str: string): string` — Same implementation as existing (replace &, <, >, ", ')
- `sendLeadNotification(data: ValidatedLeadData, source: 'main' | 'lp'): void` — Fire-and-forget email sender:
  - Creates Resend client using `process.env.RESEND_API_KEY`
  - Builds the email HTML using the same template patterns from the existing routes:
    - For `source: 'main'`: Subject prefix `[NextOffice]`, heading "Neue Lead-Anfrage", include listing row if listing_name present
    - For `source: 'lp'`: Subject prefix `[LP]`, heading "Neue LP-Anfrage", include UTM row if utm_source/utm_term present
  - Company extraction from email domain (same freeProviders Set logic as existing)
  - If `source === 'lp'` and `data.company` is provided, use it directly; otherwise extract from email domain
  - All user-provided fields wrapped in `escapeHtml()` — no exceptions
  - `encodeURIComponent()` for href values (mailto:, tel:)
  - Sends to `process.env.NOTIFICATION_EMAIL`
  - Returns void — uses `.catch(err => console.error(...))` pattern (non-blocking)
  - MUST NOT use `await` — the function returns immediately, email sends in the background
- Export both `escapeHtml` and `sendLeadNotification`

**service.ts** — Lead pipeline orchestrator (REL-04 consolidation):
- `handleLeadSubmission(request: Request, source: 'main' | 'lp'): Promise<NextResponse>` — Single entry point for both routes:
  1. Rate limiting: Import and use the existing rate limiter pattern (move it here or import from a shared location). Keep: 10 req/min/IP, in-memory Map with periodic cleanup.
  2. Parse JSON body with try/catch (return 400 on parse failure)
  3. CSRF verification: Read CSRF token from `x-csrf-token` header, read CSRF cookie from request cookies. Call `verifyCsrfToken()`. Return 403 with generic German error if invalid.
  4. Validate payload: Call `validateLeadPayload(body)`. Return 400 with the error message if invalid.
  5. Read and validate cookie tracking values: For gclid/gbraid/wbraid — first check body values (from client), then fall back to server cookies (`_no_gclid`, etc.), pass through `validateCookieValue()`.
  6. Check duplicate: If phone AND city are present, call `checkDuplicate()`. If duplicate found, return `{ success: true, deduplicated: true }` with 200 (idempotent response, not an error).
  7. Insert lead: Call `insertLead()`. Return 500 on failure.
  8. Send notification email: Call `sendLeadNotification()` — fire-and-forget, no await.
  9. Return `{ success: true }` with 200.
- Also export `handleCsrfToken(request: Request): Promise<NextResponse>` — a GET handler that generates a CSRF token pair, sets the cookie, and returns the token in the response body. This will be used by a new `/api/csrf` endpoint.
- Import NextResponse from 'next/server', cookies from 'next/headers'
- Use `import { env } from '@/lib/env'` for env var access where needed

IMPORTANT: The rate limiter should be module-level (singleton Map) in service.ts, same pattern as existing routes. Do NOT import it from the route files — move the implementation here.
  </action>
  <verify>
    <automated>cd /Users/szymonwilkosz/Library/Mobile\ Documents/com~apple~CloudDocs/claude-config/projects/next-office && npx tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>
    - src/lib/leads/email.ts exports escapeHtml and sendLeadNotification
    - src/lib/leads/service.ts exports handleLeadSubmission and handleCsrfToken
    - escapeHtml is defined once in email.ts (single source of truth)
    - Rate limiter logic is centralized in service.ts
    - Email sending uses fire-and-forget pattern (no await, .catch for error logging)
    - Duplicate detection returns idempotent success response (not an error)
    - CSRF verification reads token from x-csrf-token header + _no_csrf cookie
    - npx tsc --noEmit passes
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. All 5 files exist in src/lib/leads/ with the specified exports
3. No import of SUPABASE_SERVICE_ROLE_KEY in any of the new lead service files (scoped access only)
4. escapeHtml defined exactly once (in email.ts)
5. Rate limiter logic exists in service.ts, not duplicated
6. validateEmail rejects "hello", "@.@", "a@b" but accepts "user@example.com"
7. validateCookieValue rejects strings >150 chars or containing HTML characters
8. CSRF_COOKIE_NAME constant is "_no_csrf"
</verification>

<success_criteria>
- A complete `src/lib/leads/` module exists with validation, CSRF, scoped DB, email, and orchestrator
- All security requirements (SEC-07 through SEC-11) have corresponding implementation in the module
- All reliability requirements (REL-04 through REL-06) have corresponding implementation
- The module compiles without type errors
- Ready for Plan 02 to wire the routes to use this shared service
</success_criteria>

<output>
After completion, create `.planning/phases/03-lead-pipeline-hardening/03-01-SUMMARY.md`
</output>
